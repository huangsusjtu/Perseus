/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.6.1
 * source: map.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as pb_1 from "google-protobuf";
export namespace perseus.api.v1.map {
    export class LanePoint extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            x?: number;
            y?: number;
            z?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("x" in data && data.x != undefined) {
                    this.x = data.x;
                }
                if ("y" in data && data.y != undefined) {
                    this.y = data.y;
                }
                if ("z" in data && data.z != undefined) {
                    this.z = data.z;
                }
            }
        }
        get x() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set x(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get y() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set y(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get z() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set z(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            x?: number;
            y?: number;
            z?: number;
        }): LanePoint {
            const message = new LanePoint({});
            if (data.x != null) {
                message.x = data.x;
            }
            if (data.y != null) {
                message.y = data.y;
            }
            if (data.z != null) {
                message.z = data.z;
            }
            return message;
        }
        toObject() {
            const data: {
                x?: number;
                y?: number;
                z?: number;
            } = {};
            if (this.x != null) {
                data.x = this.x;
            }
            if (this.y != null) {
                data.y = this.y;
            }
            if (this.z != null) {
                data.z = this.z;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.x != 0)
                writer.writeDouble(1, this.x);
            if (this.y != 0)
                writer.writeDouble(2, this.y);
            if (this.z != 0)
                writer.writeDouble(3, this.z);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): LanePoint {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new LanePoint();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.x = reader.readDouble();
                        break;
                    case 2:
                        message.y = reader.readDouble();
                        break;
                    case 3:
                        message.z = reader.readDouble();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): LanePoint {
            return LanePoint.deserialize(bytes);
        }
    }
    export class CleanArea extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            id?: number;
            name?: string;
            position?: LanePoint;
            polygon?: LanePoint[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [4], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("id" in data && data.id != undefined) {
                    this.id = data.id;
                }
                if ("name" in data && data.name != undefined) {
                    this.name = data.name;
                }
                if ("position" in data && data.position != undefined) {
                    this.position = data.position;
                }
                if ("polygon" in data && data.polygon != undefined) {
                    this.polygon = data.polygon;
                }
            }
        }
        get id() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set id(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get name() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set name(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get position() {
            return pb_1.Message.getWrapperField(this, LanePoint, 3) as LanePoint;
        }
        set position(value: LanePoint) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get has_position() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get polygon() {
            return pb_1.Message.getRepeatedWrapperField(this, LanePoint, 4) as LanePoint[];
        }
        set polygon(value: LanePoint[]) {
            pb_1.Message.setRepeatedWrapperField(this, 4, value);
        }
        static fromObject(data: {
            id?: number;
            name?: string;
            position?: ReturnType<typeof LanePoint.prototype.toObject>;
            polygon?: ReturnType<typeof LanePoint.prototype.toObject>[];
        }): CleanArea {
            const message = new CleanArea({});
            if (data.id != null) {
                message.id = data.id;
            }
            if (data.name != null) {
                message.name = data.name;
            }
            if (data.position != null) {
                message.position = LanePoint.fromObject(data.position);
            }
            if (data.polygon != null) {
                message.polygon = data.polygon.map(item => LanePoint.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                id?: number;
                name?: string;
                position?: ReturnType<typeof LanePoint.prototype.toObject>;
                polygon?: ReturnType<typeof LanePoint.prototype.toObject>[];
            } = {};
            if (this.id != null) {
                data.id = this.id;
            }
            if (this.name != null) {
                data.name = this.name;
            }
            if (this.position != null) {
                data.position = this.position.toObject();
            }
            if (this.polygon != null) {
                data.polygon = this.polygon.map((item: LanePoint) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.id != 0)
                writer.writeInt32(1, this.id);
            if (this.name.length)
                writer.writeString(2, this.name);
            if (this.has_position)
                writer.writeMessage(3, this.position, () => this.position.serialize(writer));
            if (this.polygon.length)
                writer.writeRepeatedMessage(4, this.polygon, (item: LanePoint) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CleanArea {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new CleanArea();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.id = reader.readInt32();
                        break;
                    case 2:
                        message.name = reader.readString();
                        break;
                    case 3:
                        reader.readMessage(message.position, () => message.position = LanePoint.deserialize(reader));
                        break;
                    case 4:
                        reader.readMessage(message.polygon, () => pb_1.Message.addToRepeatedWrapperField(message, 4, LanePoint.deserialize(reader), LanePoint));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): CleanArea {
            return CleanArea.deserialize(bytes);
        }
    }
    export class Site extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            id?: number;
            name?: string;
            type?: Site.SiteType;
            position?: LanePoint;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("id" in data && data.id != undefined) {
                    this.id = data.id;
                }
                if ("name" in data && data.name != undefined) {
                    this.name = data.name;
                }
                if ("type" in data && data.type != undefined) {
                    this.type = data.type;
                }
                if ("position" in data && data.position != undefined) {
                    this.position = data.position;
                }
            }
        }
        get id() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set id(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get name() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set name(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get type() {
            return pb_1.Message.getFieldWithDefault(this, 3, Site.SiteType.None) as Site.SiteType;
        }
        set type(value: Site.SiteType) {
            pb_1.Message.setField(this, 3, value);
        }
        get position() {
            return pb_1.Message.getWrapperField(this, LanePoint, 4) as LanePoint;
        }
        set position(value: LanePoint) {
            pb_1.Message.setWrapperField(this, 4, value);
        }
        get has_position() {
            return pb_1.Message.getField(this, 4) != null;
        }
        static fromObject(data: {
            id?: number;
            name?: string;
            type?: Site.SiteType;
            position?: ReturnType<typeof LanePoint.prototype.toObject>;
        }): Site {
            const message = new Site({});
            if (data.id != null) {
                message.id = data.id;
            }
            if (data.name != null) {
                message.name = data.name;
            }
            if (data.type != null) {
                message.type = data.type;
            }
            if (data.position != null) {
                message.position = LanePoint.fromObject(data.position);
            }
            return message;
        }
        toObject() {
            const data: {
                id?: number;
                name?: string;
                type?: Site.SiteType;
                position?: ReturnType<typeof LanePoint.prototype.toObject>;
            } = {};
            if (this.id != null) {
                data.id = this.id;
            }
            if (this.name != null) {
                data.name = this.name;
            }
            if (this.type != null) {
                data.type = this.type;
            }
            if (this.position != null) {
                data.position = this.position.toObject();
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.id != 0)
                writer.writeInt32(1, this.id);
            if (this.name.length)
                writer.writeString(2, this.name);
            if (this.type != Site.SiteType.None)
                writer.writeEnum(3, this.type);
            if (this.has_position)
                writer.writeMessage(4, this.position, () => this.position.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Site {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Site();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.id = reader.readInt32();
                        break;
                    case 2:
                        message.name = reader.readString();
                        break;
                    case 3:
                        message.type = reader.readEnum();
                        break;
                    case 4:
                        reader.readMessage(message.position, () => message.position = LanePoint.deserialize(reader));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Site {
            return Site.deserialize(bytes);
        }
    }
    export namespace Site {
        export enum SiteType {
            None = 0,
            CleanSite = 1,
            ChargingSite = 2,
            ParkingSite = 3,
            TransferSite = 4,
            WaterSupplySite = 5,
            MaintenanceSite = 6,
            GasSite = 7
        }
    }
    export class Header extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            major_version?: number;
            minor_version?: number;
            name?: string;
            date?: string;
            coordinate?: Header.Coordinate;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("major_version" in data && data.major_version != undefined) {
                    this.major_version = data.major_version;
                }
                if ("minor_version" in data && data.minor_version != undefined) {
                    this.minor_version = data.minor_version;
                }
                if ("name" in data && data.name != undefined) {
                    this.name = data.name;
                }
                if ("date" in data && data.date != undefined) {
                    this.date = data.date;
                }
                if ("coordinate" in data && data.coordinate != undefined) {
                    this.coordinate = data.coordinate;
                }
            }
        }
        get major_version() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set major_version(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get minor_version() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set minor_version(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        get name() {
            return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
        }
        set name(value: string) {
            pb_1.Message.setField(this, 3, value);
        }
        get date() {
            return pb_1.Message.getFieldWithDefault(this, 4, "") as string;
        }
        set date(value: string) {
            pb_1.Message.setField(this, 4, value);
        }
        get coordinate() {
            return pb_1.Message.getFieldWithDefault(this, 5, Header.Coordinate.None) as Header.Coordinate;
        }
        set coordinate(value: Header.Coordinate) {
            pb_1.Message.setField(this, 5, value);
        }
        static fromObject(data: {
            major_version?: number;
            minor_version?: number;
            name?: string;
            date?: string;
            coordinate?: Header.Coordinate;
        }): Header {
            const message = new Header({});
            if (data.major_version != null) {
                message.major_version = data.major_version;
            }
            if (data.minor_version != null) {
                message.minor_version = data.minor_version;
            }
            if (data.name != null) {
                message.name = data.name;
            }
            if (data.date != null) {
                message.date = data.date;
            }
            if (data.coordinate != null) {
                message.coordinate = data.coordinate;
            }
            return message;
        }
        toObject() {
            const data: {
                major_version?: number;
                minor_version?: number;
                name?: string;
                date?: string;
                coordinate?: Header.Coordinate;
            } = {};
            if (this.major_version != null) {
                data.major_version = this.major_version;
            }
            if (this.minor_version != null) {
                data.minor_version = this.minor_version;
            }
            if (this.name != null) {
                data.name = this.name;
            }
            if (this.date != null) {
                data.date = this.date;
            }
            if (this.coordinate != null) {
                data.coordinate = this.coordinate;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.major_version != 0)
                writer.writeInt32(1, this.major_version);
            if (this.minor_version != 0)
                writer.writeInt32(2, this.minor_version);
            if (this.name.length)
                writer.writeString(3, this.name);
            if (this.date.length)
                writer.writeString(4, this.date);
            if (this.coordinate != Header.Coordinate.None)
                writer.writeEnum(5, this.coordinate);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Header {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Header();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.major_version = reader.readInt32();
                        break;
                    case 2:
                        message.minor_version = reader.readInt32();
                        break;
                    case 3:
                        message.name = reader.readString();
                        break;
                    case 4:
                        message.date = reader.readString();
                        break;
                    case 5:
                        message.coordinate = reader.readEnum();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Header {
            return Header.deserialize(bytes);
        }
    }
    export namespace Header {
        export enum Coordinate {
            None = 0,
            BD09 = 1,
            WGS84 = 2
        }
    }
    export class Junction extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            id?: number;
            name?: string;
            position?: LanePoint;
            polygon?: LanePoint[];
            connection?: Junction.ConnectionInfo[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [4, 5], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("id" in data && data.id != undefined) {
                    this.id = data.id;
                }
                if ("name" in data && data.name != undefined) {
                    this.name = data.name;
                }
                if ("position" in data && data.position != undefined) {
                    this.position = data.position;
                }
                if ("polygon" in data && data.polygon != undefined) {
                    this.polygon = data.polygon;
                }
                if ("connection" in data && data.connection != undefined) {
                    this.connection = data.connection;
                }
            }
        }
        get id() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set id(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get name() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set name(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get position() {
            return pb_1.Message.getWrapperField(this, LanePoint, 3) as LanePoint;
        }
        set position(value: LanePoint) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get has_position() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get polygon() {
            return pb_1.Message.getRepeatedWrapperField(this, LanePoint, 4) as LanePoint[];
        }
        set polygon(value: LanePoint[]) {
            pb_1.Message.setRepeatedWrapperField(this, 4, value);
        }
        get connection() {
            return pb_1.Message.getRepeatedWrapperField(this, Junction.ConnectionInfo, 5) as Junction.ConnectionInfo[];
        }
        set connection(value: Junction.ConnectionInfo[]) {
            pb_1.Message.setRepeatedWrapperField(this, 5, value);
        }
        static fromObject(data: {
            id?: number;
            name?: string;
            position?: ReturnType<typeof LanePoint.prototype.toObject>;
            polygon?: ReturnType<typeof LanePoint.prototype.toObject>[];
            connection?: ReturnType<typeof Junction.ConnectionInfo.prototype.toObject>[];
        }): Junction {
            const message = new Junction({});
            if (data.id != null) {
                message.id = data.id;
            }
            if (data.name != null) {
                message.name = data.name;
            }
            if (data.position != null) {
                message.position = LanePoint.fromObject(data.position);
            }
            if (data.polygon != null) {
                message.polygon = data.polygon.map(item => LanePoint.fromObject(item));
            }
            if (data.connection != null) {
                message.connection = data.connection.map(item => Junction.ConnectionInfo.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                id?: number;
                name?: string;
                position?: ReturnType<typeof LanePoint.prototype.toObject>;
                polygon?: ReturnType<typeof LanePoint.prototype.toObject>[];
                connection?: ReturnType<typeof Junction.ConnectionInfo.prototype.toObject>[];
            } = {};
            if (this.id != null) {
                data.id = this.id;
            }
            if (this.name != null) {
                data.name = this.name;
            }
            if (this.position != null) {
                data.position = this.position.toObject();
            }
            if (this.polygon != null) {
                data.polygon = this.polygon.map((item: LanePoint) => item.toObject());
            }
            if (this.connection != null) {
                data.connection = this.connection.map((item: Junction.ConnectionInfo) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.id != 0)
                writer.writeInt32(1, this.id);
            if (this.name.length)
                writer.writeString(2, this.name);
            if (this.has_position)
                writer.writeMessage(3, this.position, () => this.position.serialize(writer));
            if (this.polygon.length)
                writer.writeRepeatedMessage(4, this.polygon, (item: LanePoint) => item.serialize(writer));
            if (this.connection.length)
                writer.writeRepeatedMessage(5, this.connection, (item: Junction.ConnectionInfo) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Junction {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Junction();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.id = reader.readInt32();
                        break;
                    case 2:
                        message.name = reader.readString();
                        break;
                    case 3:
                        reader.readMessage(message.position, () => message.position = LanePoint.deserialize(reader));
                        break;
                    case 4:
                        reader.readMessage(message.polygon, () => pb_1.Message.addToRepeatedWrapperField(message, 4, LanePoint.deserialize(reader), LanePoint));
                        break;
                    case 5:
                        reader.readMessage(message.connection, () => pb_1.Message.addToRepeatedWrapperField(message, 5, Junction.ConnectionInfo.deserialize(reader), Junction.ConnectionInfo));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Junction {
            return Junction.deserialize(bytes);
        }
    }
    export namespace Junction {
        export class ConnectionInfo extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                id?: number;
                road_in?: string;
                road_out?: string;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("id" in data && data.id != undefined) {
                        this.id = data.id;
                    }
                    if ("road_in" in data && data.road_in != undefined) {
                        this.road_in = data.road_in;
                    }
                    if ("road_out" in data && data.road_out != undefined) {
                        this.road_out = data.road_out;
                    }
                }
            }
            get id() {
                return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
            }
            set id(value: number) {
                pb_1.Message.setField(this, 1, value);
            }
            get road_in() {
                return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
            }
            set road_in(value: string) {
                pb_1.Message.setField(this, 2, value);
            }
            get road_out() {
                return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
            }
            set road_out(value: string) {
                pb_1.Message.setField(this, 3, value);
            }
            static fromObject(data: {
                id?: number;
                road_in?: string;
                road_out?: string;
            }): ConnectionInfo {
                const message = new ConnectionInfo({});
                if (data.id != null) {
                    message.id = data.id;
                }
                if (data.road_in != null) {
                    message.road_in = data.road_in;
                }
                if (data.road_out != null) {
                    message.road_out = data.road_out;
                }
                return message;
            }
            toObject() {
                const data: {
                    id?: number;
                    road_in?: string;
                    road_out?: string;
                } = {};
                if (this.id != null) {
                    data.id = this.id;
                }
                if (this.road_in != null) {
                    data.road_in = this.road_in;
                }
                if (this.road_out != null) {
                    data.road_out = this.road_out;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.id != 0)
                    writer.writeInt32(1, this.id);
                if (this.road_in.length)
                    writer.writeString(2, this.road_in);
                if (this.road_out.length)
                    writer.writeString(3, this.road_out);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ConnectionInfo {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ConnectionInfo();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.id = reader.readInt32();
                            break;
                        case 2:
                            message.road_in = reader.readString();
                            break;
                        case 3:
                            message.road_out = reader.readString();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): ConnectionInfo {
                return ConnectionInfo.deserialize(bytes);
            }
        }
    }
    export class Lane extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            id?: number;
            type?: Lane.LaneType;
            central_line?: LineCurve;
            width?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("id" in data && data.id != undefined) {
                    this.id = data.id;
                }
                if ("type" in data && data.type != undefined) {
                    this.type = data.type;
                }
                if ("central_line" in data && data.central_line != undefined) {
                    this.central_line = data.central_line;
                }
                if ("width" in data && data.width != undefined) {
                    this.width = data.width;
                }
            }
        }
        get id() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set id(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get type() {
            return pb_1.Message.getFieldWithDefault(this, 2, Lane.LaneType.NONE) as Lane.LaneType;
        }
        set type(value: Lane.LaneType) {
            pb_1.Message.setField(this, 2, value);
        }
        get central_line() {
            return pb_1.Message.getWrapperField(this, LineCurve, 3) as LineCurve;
        }
        set central_line(value: LineCurve) {
            pb_1.Message.setWrapperField(this, 3, value);
        }
        get has_central_line() {
            return pb_1.Message.getField(this, 3) != null;
        }
        get width() {
            return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
        }
        set width(value: number) {
            pb_1.Message.setField(this, 4, value);
        }
        static fromObject(data: {
            id?: number;
            type?: Lane.LaneType;
            central_line?: ReturnType<typeof LineCurve.prototype.toObject>;
            width?: number;
        }): Lane {
            const message = new Lane({});
            if (data.id != null) {
                message.id = data.id;
            }
            if (data.type != null) {
                message.type = data.type;
            }
            if (data.central_line != null) {
                message.central_line = LineCurve.fromObject(data.central_line);
            }
            if (data.width != null) {
                message.width = data.width;
            }
            return message;
        }
        toObject() {
            const data: {
                id?: number;
                type?: Lane.LaneType;
                central_line?: ReturnType<typeof LineCurve.prototype.toObject>;
                width?: number;
            } = {};
            if (this.id != null) {
                data.id = this.id;
            }
            if (this.type != null) {
                data.type = this.type;
            }
            if (this.central_line != null) {
                data.central_line = this.central_line.toObject();
            }
            if (this.width != null) {
                data.width = this.width;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.id != 0)
                writer.writeInt32(1, this.id);
            if (this.type != Lane.LaneType.NONE)
                writer.writeEnum(2, this.type);
            if (this.has_central_line)
                writer.writeMessage(3, this.central_line, () => this.central_line.serialize(writer));
            if (this.width != 0)
                writer.writeFloat(4, this.width);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Lane {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Lane();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.id = reader.readInt32();
                        break;
                    case 2:
                        message.type = reader.readEnum();
                        break;
                    case 3:
                        reader.readMessage(message.central_line, () => message.central_line = LineCurve.deserialize(reader));
                        break;
                    case 4:
                        message.width = reader.readFloat();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Lane {
            return Lane.deserialize(bytes);
        }
    }
    export namespace Lane {
        export enum LaneType {
            NONE = 0,
            CityDriving = 1,
            SideWalk = 2,
            Shoulder = 3,
            Bus = 4,
            Biking = 5,
            Parking = 6,
            Bidirectional = 7
        }
    }
    export class LineCurve extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            segments?: LineCurve.GeometryLine[];
            length?: number;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("segments" in data && data.segments != undefined) {
                    this.segments = data.segments;
                }
                if ("length" in data && data.length != undefined) {
                    this.length = data.length;
                }
            }
        }
        get segments() {
            return pb_1.Message.getRepeatedWrapperField(this, LineCurve.GeometryLine, 1) as LineCurve.GeometryLine[];
        }
        set segments(value: LineCurve.GeometryLine[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        get length() {
            return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
        }
        set length(value: number) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            segments?: ReturnType<typeof LineCurve.GeometryLine.prototype.toObject>[];
            length?: number;
        }): LineCurve {
            const message = new LineCurve({});
            if (data.segments != null) {
                message.segments = data.segments.map(item => LineCurve.GeometryLine.fromObject(item));
            }
            if (data.length != null) {
                message.length = data.length;
            }
            return message;
        }
        toObject() {
            const data: {
                segments?: ReturnType<typeof LineCurve.GeometryLine.prototype.toObject>[];
                length?: number;
            } = {};
            if (this.segments != null) {
                data.segments = this.segments.map((item: LineCurve.GeometryLine) => item.toObject());
            }
            if (this.length != null) {
                data.length = this.length;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.segments.length)
                writer.writeRepeatedMessage(1, this.segments, (item: LineCurve.GeometryLine) => item.serialize(writer));
            if (this.length != 0)
                writer.writeFloat(2, this.length);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): LineCurve {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new LineCurve();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.segments, () => pb_1.Message.addToRepeatedWrapperField(message, 1, LineCurve.GeometryLine.deserialize(reader), LineCurve.GeometryLine));
                        break;
                    case 2:
                        message.length = reader.readFloat();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): LineCurve {
            return LineCurve.deserialize(bytes);
        }
    }
    export namespace LineCurve {
        export class StraightLine extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                hdg?: number;
                length?: number;
                start_s?: number;
                position?: LanePoint;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("hdg" in data && data.hdg != undefined) {
                        this.hdg = data.hdg;
                    }
                    if ("length" in data && data.length != undefined) {
                        this.length = data.length;
                    }
                    if ("start_s" in data && data.start_s != undefined) {
                        this.start_s = data.start_s;
                    }
                    if ("position" in data && data.position != undefined) {
                        this.position = data.position;
                    }
                }
            }
            get hdg() {
                return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
            }
            set hdg(value: number) {
                pb_1.Message.setField(this, 1, value);
            }
            get length() {
                return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
            }
            set length(value: number) {
                pb_1.Message.setField(this, 2, value);
            }
            get start_s() {
                return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
            }
            set start_s(value: number) {
                pb_1.Message.setField(this, 3, value);
            }
            get position() {
                return pb_1.Message.getWrapperField(this, LanePoint, 4) as LanePoint;
            }
            set position(value: LanePoint) {
                pb_1.Message.setWrapperField(this, 4, value);
            }
            get has_position() {
                return pb_1.Message.getField(this, 4) != null;
            }
            static fromObject(data: {
                hdg?: number;
                length?: number;
                start_s?: number;
                position?: ReturnType<typeof LanePoint.prototype.toObject>;
            }): StraightLine {
                const message = new StraightLine({});
                if (data.hdg != null) {
                    message.hdg = data.hdg;
                }
                if (data.length != null) {
                    message.length = data.length;
                }
                if (data.start_s != null) {
                    message.start_s = data.start_s;
                }
                if (data.position != null) {
                    message.position = LanePoint.fromObject(data.position);
                }
                return message;
            }
            toObject() {
                const data: {
                    hdg?: number;
                    length?: number;
                    start_s?: number;
                    position?: ReturnType<typeof LanePoint.prototype.toObject>;
                } = {};
                if (this.hdg != null) {
                    data.hdg = this.hdg;
                }
                if (this.length != null) {
                    data.length = this.length;
                }
                if (this.start_s != null) {
                    data.start_s = this.start_s;
                }
                if (this.position != null) {
                    data.position = this.position.toObject();
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.hdg != 0)
                    writer.writeFloat(1, this.hdg);
                if (this.length != 0)
                    writer.writeFloat(2, this.length);
                if (this.start_s != 0)
                    writer.writeFloat(3, this.start_s);
                if (this.has_position)
                    writer.writeMessage(4, this.position, () => this.position.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): StraightLine {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new StraightLine();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.hdg = reader.readFloat();
                            break;
                        case 2:
                            message.length = reader.readFloat();
                            break;
                        case 3:
                            message.start_s = reader.readFloat();
                            break;
                        case 4:
                            reader.readMessage(message.position, () => message.position = LanePoint.deserialize(reader));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): StraightLine {
                return StraightLine.deserialize(bytes);
            }
        }
        export class ArcLine extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                hdg?: number;
                length?: number;
                start_s?: number;
                position?: LanePoint;
                curvature?: number;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("hdg" in data && data.hdg != undefined) {
                        this.hdg = data.hdg;
                    }
                    if ("length" in data && data.length != undefined) {
                        this.length = data.length;
                    }
                    if ("start_s" in data && data.start_s != undefined) {
                        this.start_s = data.start_s;
                    }
                    if ("position" in data && data.position != undefined) {
                        this.position = data.position;
                    }
                    if ("curvature" in data && data.curvature != undefined) {
                        this.curvature = data.curvature;
                    }
                }
            }
            get hdg() {
                return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
            }
            set hdg(value: number) {
                pb_1.Message.setField(this, 1, value);
            }
            get length() {
                return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
            }
            set length(value: number) {
                pb_1.Message.setField(this, 2, value);
            }
            get start_s() {
                return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
            }
            set start_s(value: number) {
                pb_1.Message.setField(this, 3, value);
            }
            get position() {
                return pb_1.Message.getWrapperField(this, LanePoint, 4) as LanePoint;
            }
            set position(value: LanePoint) {
                pb_1.Message.setWrapperField(this, 4, value);
            }
            get has_position() {
                return pb_1.Message.getField(this, 4) != null;
            }
            get curvature() {
                return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
            }
            set curvature(value: number) {
                pb_1.Message.setField(this, 5, value);
            }
            static fromObject(data: {
                hdg?: number;
                length?: number;
                start_s?: number;
                position?: ReturnType<typeof LanePoint.prototype.toObject>;
                curvature?: number;
            }): ArcLine {
                const message = new ArcLine({});
                if (data.hdg != null) {
                    message.hdg = data.hdg;
                }
                if (data.length != null) {
                    message.length = data.length;
                }
                if (data.start_s != null) {
                    message.start_s = data.start_s;
                }
                if (data.position != null) {
                    message.position = LanePoint.fromObject(data.position);
                }
                if (data.curvature != null) {
                    message.curvature = data.curvature;
                }
                return message;
            }
            toObject() {
                const data: {
                    hdg?: number;
                    length?: number;
                    start_s?: number;
                    position?: ReturnType<typeof LanePoint.prototype.toObject>;
                    curvature?: number;
                } = {};
                if (this.hdg != null) {
                    data.hdg = this.hdg;
                }
                if (this.length != null) {
                    data.length = this.length;
                }
                if (this.start_s != null) {
                    data.start_s = this.start_s;
                }
                if (this.position != null) {
                    data.position = this.position.toObject();
                }
                if (this.curvature != null) {
                    data.curvature = this.curvature;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.hdg != 0)
                    writer.writeFloat(1, this.hdg);
                if (this.length != 0)
                    writer.writeFloat(2, this.length);
                if (this.start_s != 0)
                    writer.writeFloat(3, this.start_s);
                if (this.has_position)
                    writer.writeMessage(4, this.position, () => this.position.serialize(writer));
                if (this.curvature != 0)
                    writer.writeFloat(5, this.curvature);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ArcLine {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ArcLine();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.hdg = reader.readFloat();
                            break;
                        case 2:
                            message.length = reader.readFloat();
                            break;
                        case 3:
                            message.start_s = reader.readFloat();
                            break;
                        case 4:
                            reader.readMessage(message.position, () => message.position = LanePoint.deserialize(reader));
                            break;
                        case 5:
                            message.curvature = reader.readFloat();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): ArcLine {
                return ArcLine.deserialize(bytes);
            }
        }
        export class GeometryLine extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                straight?: LineCurve.StraightLine;
                arc?: LineCurve.ArcLine;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("straight" in data && data.straight != undefined) {
                        this.straight = data.straight;
                    }
                    if ("arc" in data && data.arc != undefined) {
                        this.arc = data.arc;
                    }
                }
            }
            get straight() {
                return pb_1.Message.getWrapperField(this, LineCurve.StraightLine, 1) as LineCurve.StraightLine;
            }
            set straight(value: LineCurve.StraightLine) {
                pb_1.Message.setWrapperField(this, 1, value);
            }
            get has_straight() {
                return pb_1.Message.getField(this, 1) != null;
            }
            get arc() {
                return pb_1.Message.getWrapperField(this, LineCurve.ArcLine, 2) as LineCurve.ArcLine;
            }
            set arc(value: LineCurve.ArcLine) {
                pb_1.Message.setWrapperField(this, 2, value);
            }
            get has_arc() {
                return pb_1.Message.getField(this, 2) != null;
            }
            static fromObject(data: {
                straight?: ReturnType<typeof LineCurve.StraightLine.prototype.toObject>;
                arc?: ReturnType<typeof LineCurve.ArcLine.prototype.toObject>;
            }): GeometryLine {
                const message = new GeometryLine({});
                if (data.straight != null) {
                    message.straight = LineCurve.StraightLine.fromObject(data.straight);
                }
                if (data.arc != null) {
                    message.arc = LineCurve.ArcLine.fromObject(data.arc);
                }
                return message;
            }
            toObject() {
                const data: {
                    straight?: ReturnType<typeof LineCurve.StraightLine.prototype.toObject>;
                    arc?: ReturnType<typeof LineCurve.ArcLine.prototype.toObject>;
                } = {};
                if (this.straight != null) {
                    data.straight = this.straight.toObject();
                }
                if (this.arc != null) {
                    data.arc = this.arc.toObject();
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.has_straight)
                    writer.writeMessage(1, this.straight, () => this.straight.serialize(writer));
                if (this.has_arc)
                    writer.writeMessage(2, this.arc, () => this.arc.serialize(writer));
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): GeometryLine {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new GeometryLine();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            reader.readMessage(message.straight, () => message.straight = LineCurve.StraightLine.deserialize(reader));
                            break;
                        case 2:
                            reader.readMessage(message.arc, () => message.arc = LineCurve.ArcLine.deserialize(reader));
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): GeometryLine {
                return GeometryLine.deserialize(bytes);
            }
        }
    }
    export class Road extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            id?: number;
            name?: string;
            length?: number;
            type?: Road.RoadType;
            central_line?: LineCurve;
            left_lanes?: Lane[];
            right_lanes?: Lane[];
            link?: Road.RoadLink[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [6, 7, 8], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("id" in data && data.id != undefined) {
                    this.id = data.id;
                }
                if ("name" in data && data.name != undefined) {
                    this.name = data.name;
                }
                if ("length" in data && data.length != undefined) {
                    this.length = data.length;
                }
                if ("type" in data && data.type != undefined) {
                    this.type = data.type;
                }
                if ("central_line" in data && data.central_line != undefined) {
                    this.central_line = data.central_line;
                }
                if ("left_lanes" in data && data.left_lanes != undefined) {
                    this.left_lanes = data.left_lanes;
                }
                if ("right_lanes" in data && data.right_lanes != undefined) {
                    this.right_lanes = data.right_lanes;
                }
                if ("link" in data && data.link != undefined) {
                    this.link = data.link;
                }
            }
        }
        get id() {
            return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
        }
        set id(value: number) {
            pb_1.Message.setField(this, 1, value);
        }
        get name() {
            return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
        }
        set name(value: string) {
            pb_1.Message.setField(this, 2, value);
        }
        get length() {
            return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
        }
        set length(value: number) {
            pb_1.Message.setField(this, 3, value);
        }
        get type() {
            return pb_1.Message.getFieldWithDefault(this, 4, Road.RoadType.None) as Road.RoadType;
        }
        set type(value: Road.RoadType) {
            pb_1.Message.setField(this, 4, value);
        }
        get central_line() {
            return pb_1.Message.getWrapperField(this, LineCurve, 5) as LineCurve;
        }
        set central_line(value: LineCurve) {
            pb_1.Message.setWrapperField(this, 5, value);
        }
        get has_central_line() {
            return pb_1.Message.getField(this, 5) != null;
        }
        get left_lanes() {
            return pb_1.Message.getRepeatedWrapperField(this, Lane, 6) as Lane[];
        }
        set left_lanes(value: Lane[]) {
            pb_1.Message.setRepeatedWrapperField(this, 6, value);
        }
        get right_lanes() {
            return pb_1.Message.getRepeatedWrapperField(this, Lane, 7) as Lane[];
        }
        set right_lanes(value: Lane[]) {
            pb_1.Message.setRepeatedWrapperField(this, 7, value);
        }
        get link() {
            return pb_1.Message.getRepeatedWrapperField(this, Road.RoadLink, 8) as Road.RoadLink[];
        }
        set link(value: Road.RoadLink[]) {
            pb_1.Message.setRepeatedWrapperField(this, 8, value);
        }
        static fromObject(data: {
            id?: number;
            name?: string;
            length?: number;
            type?: Road.RoadType;
            central_line?: ReturnType<typeof LineCurve.prototype.toObject>;
            left_lanes?: ReturnType<typeof Lane.prototype.toObject>[];
            right_lanes?: ReturnType<typeof Lane.prototype.toObject>[];
            link?: ReturnType<typeof Road.RoadLink.prototype.toObject>[];
        }): Road {
            const message = new Road({});
            if (data.id != null) {
                message.id = data.id;
            }
            if (data.name != null) {
                message.name = data.name;
            }
            if (data.length != null) {
                message.length = data.length;
            }
            if (data.type != null) {
                message.type = data.type;
            }
            if (data.central_line != null) {
                message.central_line = LineCurve.fromObject(data.central_line);
            }
            if (data.left_lanes != null) {
                message.left_lanes = data.left_lanes.map(item => Lane.fromObject(item));
            }
            if (data.right_lanes != null) {
                message.right_lanes = data.right_lanes.map(item => Lane.fromObject(item));
            }
            if (data.link != null) {
                message.link = data.link.map(item => Road.RoadLink.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                id?: number;
                name?: string;
                length?: number;
                type?: Road.RoadType;
                central_line?: ReturnType<typeof LineCurve.prototype.toObject>;
                left_lanes?: ReturnType<typeof Lane.prototype.toObject>[];
                right_lanes?: ReturnType<typeof Lane.prototype.toObject>[];
                link?: ReturnType<typeof Road.RoadLink.prototype.toObject>[];
            } = {};
            if (this.id != null) {
                data.id = this.id;
            }
            if (this.name != null) {
                data.name = this.name;
            }
            if (this.length != null) {
                data.length = this.length;
            }
            if (this.type != null) {
                data.type = this.type;
            }
            if (this.central_line != null) {
                data.central_line = this.central_line.toObject();
            }
            if (this.left_lanes != null) {
                data.left_lanes = this.left_lanes.map((item: Lane) => item.toObject());
            }
            if (this.right_lanes != null) {
                data.right_lanes = this.right_lanes.map((item: Lane) => item.toObject());
            }
            if (this.link != null) {
                data.link = this.link.map((item: Road.RoadLink) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.id != 0)
                writer.writeInt32(1, this.id);
            if (this.name.length)
                writer.writeString(2, this.name);
            if (this.length != 0)
                writer.writeFloat(3, this.length);
            if (this.type != Road.RoadType.None)
                writer.writeEnum(4, this.type);
            if (this.has_central_line)
                writer.writeMessage(5, this.central_line, () => this.central_line.serialize(writer));
            if (this.left_lanes.length)
                writer.writeRepeatedMessage(6, this.left_lanes, (item: Lane) => item.serialize(writer));
            if (this.right_lanes.length)
                writer.writeRepeatedMessage(7, this.right_lanes, (item: Lane) => item.serialize(writer));
            if (this.link.length)
                writer.writeRepeatedMessage(8, this.link, (item: Road.RoadLink) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Road {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Road();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.id = reader.readInt32();
                        break;
                    case 2:
                        message.name = reader.readString();
                        break;
                    case 3:
                        message.length = reader.readFloat();
                        break;
                    case 4:
                        message.type = reader.readEnum();
                        break;
                    case 5:
                        reader.readMessage(message.central_line, () => message.central_line = LineCurve.deserialize(reader));
                        break;
                    case 6:
                        reader.readMessage(message.left_lanes, () => pb_1.Message.addToRepeatedWrapperField(message, 6, Lane.deserialize(reader), Lane));
                        break;
                    case 7:
                        reader.readMessage(message.right_lanes, () => pb_1.Message.addToRepeatedWrapperField(message, 7, Lane.deserialize(reader), Lane));
                        break;
                    case 8:
                        reader.readMessage(message.link, () => pb_1.Message.addToRepeatedWrapperField(message, 8, Road.RoadLink.deserialize(reader), Road.RoadLink));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Road {
            return Road.deserialize(bytes);
        }
    }
    export namespace Road {
        export enum RoadType {
            None = 0,
            Major = 1,
            Minor = 2,
            SideWalk = 3
        }
        export class RoadLink extends pb_1.Message {
            #one_of_decls: number[][] = [];
            constructor(data?: any[] | {
                link_type?: string;
                element_type?: string;
                element_id?: number;
            }) {
                super();
                pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
                if (!Array.isArray(data) && typeof data == "object") {
                    if ("link_type" in data && data.link_type != undefined) {
                        this.link_type = data.link_type;
                    }
                    if ("element_type" in data && data.element_type != undefined) {
                        this.element_type = data.element_type;
                    }
                    if ("element_id" in data && data.element_id != undefined) {
                        this.element_id = data.element_id;
                    }
                }
            }
            get link_type() {
                return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
            }
            set link_type(value: string) {
                pb_1.Message.setField(this, 1, value);
            }
            get element_type() {
                return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
            }
            set element_type(value: string) {
                pb_1.Message.setField(this, 2, value);
            }
            get element_id() {
                return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
            }
            set element_id(value: number) {
                pb_1.Message.setField(this, 3, value);
            }
            static fromObject(data: {
                link_type?: string;
                element_type?: string;
                element_id?: number;
            }): RoadLink {
                const message = new RoadLink({});
                if (data.link_type != null) {
                    message.link_type = data.link_type;
                }
                if (data.element_type != null) {
                    message.element_type = data.element_type;
                }
                if (data.element_id != null) {
                    message.element_id = data.element_id;
                }
                return message;
            }
            toObject() {
                const data: {
                    link_type?: string;
                    element_type?: string;
                    element_id?: number;
                } = {};
                if (this.link_type != null) {
                    data.link_type = this.link_type;
                }
                if (this.element_type != null) {
                    data.element_type = this.element_type;
                }
                if (this.element_id != null) {
                    data.element_id = this.element_id;
                }
                return data;
            }
            serialize(): Uint8Array;
            serialize(w: pb_1.BinaryWriter): void;
            serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
                const writer = w || new pb_1.BinaryWriter();
                if (this.link_type.length)
                    writer.writeString(1, this.link_type);
                if (this.element_type.length)
                    writer.writeString(2, this.element_type);
                if (this.element_id != 0)
                    writer.writeInt32(3, this.element_id);
                if (!w)
                    return writer.getResultBuffer();
            }
            static deserialize(bytes: Uint8Array | pb_1.BinaryReader): RoadLink {
                const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new RoadLink();
                while (reader.nextField()) {
                    if (reader.isEndGroup())
                        break;
                    switch (reader.getFieldNumber()) {
                        case 1:
                            message.link_type = reader.readString();
                            break;
                        case 2:
                            message.element_type = reader.readString();
                            break;
                        case 3:
                            message.element_id = reader.readInt32();
                            break;
                        default: reader.skipField();
                    }
                }
                return message;
            }
            serializeBinary(): Uint8Array {
                return this.serialize();
            }
            static deserializeBinary(bytes: Uint8Array): RoadLink {
                return RoadLink.deserialize(bytes);
            }
        }
    }
    export class Map extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            header?: Header;
            roads?: Map<string, Road>;
            junctions?: Map<string, Junction>;
            clean_areas?: Map<string, CleanArea>;
            sites?: Map<string, Site>;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("header" in data && data.header != undefined) {
                    this.header = data.header;
                }
                if ("roads" in data && data.roads != undefined) {
                    this.roads = data.roads;
                }
                if ("junctions" in data && data.junctions != undefined) {
                    this.junctions = data.junctions;
                }
                if ("clean_areas" in data && data.clean_areas != undefined) {
                    this.clean_areas = data.clean_areas;
                }
                if ("sites" in data && data.sites != undefined) {
                    this.sites = data.sites;
                }
            }
            if (!this.roads)
                this.roads = new Map();
            if (!this.junctions)
                this.junctions = new Map();
            if (!this.clean_areas)
                this.clean_areas = new Map();
            if (!this.sites)
                this.sites = new Map();
        }
        get header() {
            return pb_1.Message.getWrapperField(this, Header, 1) as Header;
        }
        set header(value: Header) {
            pb_1.Message.setWrapperField(this, 1, value);
        }
        get has_header() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get roads() {
            return pb_1.Message.getField(this, 2) as any as Map<string, Road>;
        }
        set roads(value: Map<string, Road>) {
            pb_1.Message.setField(this, 2, value as any);
        }
        get junctions() {
            return pb_1.Message.getField(this, 3) as any as Map<string, Junction>;
        }
        set junctions(value: Map<string, Junction>) {
            pb_1.Message.setField(this, 3, value as any);
        }
        get clean_areas() {
            return pb_1.Message.getField(this, 4) as any as Map<string, CleanArea>;
        }
        set clean_areas(value: Map<string, CleanArea>) {
            pb_1.Message.setField(this, 4, value as any);
        }
        get sites() {
            return pb_1.Message.getField(this, 5) as any as Map<string, Site>;
        }
        set sites(value: Map<string, Site>) {
            pb_1.Message.setField(this, 5, value as any);
        }
        static fromObject(data: {
            header?: ReturnType<typeof Header.prototype.toObject>;
            roads?: {
                [key: string]: ReturnType<typeof Road.prototype.toObject>;
            };
            junctions?: {
                [key: string]: ReturnType<typeof Junction.prototype.toObject>;
            };
            clean_areas?: {
                [key: string]: ReturnType<typeof CleanArea.prototype.toObject>;
            };
            sites?: {
                [key: string]: ReturnType<typeof Site.prototype.toObject>;
            };
        }): Map {
            const message = new Map({});
            if (data.header != null) {
                message.header = Header.fromObject(data.header);
            }
            if (typeof data.roads == "object") {
                message.roads = new Map(Object.entries(data.roads).map(([key, value]) => [key, Road.fromObject(value)]));
            }
            if (typeof data.junctions == "object") {
                message.junctions = new Map(Object.entries(data.junctions).map(([key, value]) => [key, Junction.fromObject(value)]));
            }
            if (typeof data.clean_areas == "object") {
                message.clean_areas = new Map(Object.entries(data.clean_areas).map(([key, value]) => [key, CleanArea.fromObject(value)]));
            }
            if (typeof data.sites == "object") {
                message.sites = new Map(Object.entries(data.sites).map(([key, value]) => [key, Site.fromObject(value)]));
            }
            return message;
        }
        toObject() {
            const data: {
                header?: ReturnType<typeof Header.prototype.toObject>;
                roads?: {
                    [key: string]: ReturnType<typeof Road.prototype.toObject>;
                };
                junctions?: {
                    [key: string]: ReturnType<typeof Junction.prototype.toObject>;
                };
                clean_areas?: {
                    [key: string]: ReturnType<typeof CleanArea.prototype.toObject>;
                };
                sites?: {
                    [key: string]: ReturnType<typeof Site.prototype.toObject>;
                };
            } = {};
            if (this.header != null) {
                data.header = this.header.toObject();
            }
            if (this.roads != null) {
                data.roads = (Object.fromEntries)((Array.from)(this.roads).map(([key, value]) => [key, value.toObject()]));
            }
            if (this.junctions != null) {
                data.junctions = (Object.fromEntries)((Array.from)(this.junctions).map(([key, value]) => [key, value.toObject()]));
            }
            if (this.clean_areas != null) {
                data.clean_areas = (Object.fromEntries)((Array.from)(this.clean_areas).map(([key, value]) => [key, value.toObject()]));
            }
            if (this.sites != null) {
                data.sites = (Object.fromEntries)((Array.from)(this.sites).map(([key, value]) => [key, value.toObject()]));
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_header)
                writer.writeMessage(1, this.header, () => this.header.serialize(writer));
            for (const [key, value] of this.roads) {
                writer.writeMessage(2, this.roads, () => {
                    writer.writeString(1, key);
                    writer.writeMessage(2, value, () => value.serialize(writer));
                });
            }
            for (const [key, value] of this.junctions) {
                writer.writeMessage(3, this.junctions, () => {
                    writer.writeString(1, key);
                    writer.writeMessage(2, value, () => value.serialize(writer));
                });
            }
            for (const [key, value] of this.clean_areas) {
                writer.writeMessage(4, this.clean_areas, () => {
                    writer.writeString(1, key);
                    writer.writeMessage(2, value, () => value.serialize(writer));
                });
            }
            for (const [key, value] of this.sites) {
                writer.writeMessage(5, this.sites, () => {
                    writer.writeString(1, key);
                    writer.writeMessage(2, value, () => value.serialize(writer));
                });
            }
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Map {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Map();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.header, () => message.header = Header.deserialize(reader));
                        break;
                    case 2:
                        reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.roads as any, reader, reader.readString, () => {
                            let value;
                            reader.readMessage(message, () => value = Road.deserialize(reader));
                            return value;
                        }));
                        break;
                    case 3:
                        reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.junctions as any, reader, reader.readString, () => {
                            let value;
                            reader.readMessage(message, () => value = Junction.deserialize(reader));
                            return value;
                        }));
                        break;
                    case 4:
                        reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.clean_areas as any, reader, reader.readString, () => {
                            let value;
                            reader.readMessage(message, () => value = CleanArea.deserialize(reader));
                            return value;
                        }));
                        break;
                    case 5:
                        reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.sites as any, reader, reader.readString, () => {
                            let value;
                            reader.readMessage(message, () => value = Site.deserialize(reader));
                            return value;
                        }));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): Map {
            return Map.deserialize(bytes);
        }
    }
}
