// This file is generated by rust-protobuf 3.5.0. Do not edit
// .proto file is parsed by protoc 3.13.0
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `map.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_5_0;

// @@protoc_insertion_point(message:perseus.api.v1.map.LanePoint)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LanePoint {
    // message fields
    // @@protoc_insertion_point(field:perseus.api.v1.map.LanePoint.x)
    pub x: f64,
    // @@protoc_insertion_point(field:perseus.api.v1.map.LanePoint.y)
    pub y: f64,
    // @@protoc_insertion_point(field:perseus.api.v1.map.LanePoint.z)
    pub z: f64,
    // special fields
    // @@protoc_insertion_point(special_field:perseus.api.v1.map.LanePoint.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LanePoint {
    fn default() -> &'a LanePoint {
        <LanePoint as ::protobuf::Message>::default_instance()
    }
}

impl LanePoint {
    pub fn new() -> LanePoint {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "x",
            |m: &LanePoint| { &m.x },
            |m: &mut LanePoint| { &mut m.x },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "y",
            |m: &LanePoint| { &m.y },
            |m: &mut LanePoint| { &mut m.y },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "z",
            |m: &LanePoint| { &m.z },
            |m: &mut LanePoint| { &mut m.z },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LanePoint>(
            "LanePoint",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LanePoint {
    const NAME: &'static str = "LanePoint";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.x = is.read_double()?;
                },
                17 => {
                    self.y = is.read_double()?;
                },
                25 => {
                    self.z = is.read_double()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.x != 0. {
            my_size += 1 + 8;
        }
        if self.y != 0. {
            my_size += 1 + 8;
        }
        if self.z != 0. {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.x != 0. {
            os.write_double(1, self.x)?;
        }
        if self.y != 0. {
            os.write_double(2, self.y)?;
        }
        if self.z != 0. {
            os.write_double(3, self.z)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LanePoint {
        LanePoint::new()
    }

    fn clear(&mut self) {
        self.x = 0.;
        self.y = 0.;
        self.z = 0.;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LanePoint {
        static instance: LanePoint = LanePoint {
            x: 0.,
            y: 0.,
            z: 0.,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LanePoint {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LanePoint").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LanePoint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LanePoint {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:perseus.api.v1.map.CleanArea)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CleanArea {
    // message fields
    // @@protoc_insertion_point(field:perseus.api.v1.map.CleanArea.id)
    pub id: i32,
    // @@protoc_insertion_point(field:perseus.api.v1.map.CleanArea.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:perseus.api.v1.map.CleanArea.position)
    pub position: ::protobuf::MessageField<LanePoint>,
    // @@protoc_insertion_point(field:perseus.api.v1.map.CleanArea.polygon)
    pub polygon: ::std::vec::Vec<LanePoint>,
    // special fields
    // @@protoc_insertion_point(special_field:perseus.api.v1.map.CleanArea.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CleanArea {
    fn default() -> &'a CleanArea {
        <CleanArea as ::protobuf::Message>::default_instance()
    }
}

impl CleanArea {
    pub fn new() -> CleanArea {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &CleanArea| { &m.id },
            |m: &mut CleanArea| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &CleanArea| { &m.name },
            |m: &mut CleanArea| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LanePoint>(
            "position",
            |m: &CleanArea| { &m.position },
            |m: &mut CleanArea| { &mut m.position },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "polygon",
            |m: &CleanArea| { &m.polygon },
            |m: &mut CleanArea| { &mut m.polygon },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CleanArea>(
            "CleanArea",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CleanArea {
    const NAME: &'static str = "CleanArea";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_int32()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.position)?;
                },
                34 => {
                    self.polygon.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if let Some(v) = self.position.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.polygon {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_int32(1, self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if let Some(v) = self.position.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        for v in &self.polygon {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CleanArea {
        CleanArea::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.name.clear();
        self.position.clear();
        self.polygon.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CleanArea {
        static instance: CleanArea = CleanArea {
            id: 0,
            name: ::std::string::String::new(),
            position: ::protobuf::MessageField::none(),
            polygon: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CleanArea {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CleanArea").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CleanArea {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CleanArea {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:perseus.api.v1.map.Site)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Site {
    // message fields
    // @@protoc_insertion_point(field:perseus.api.v1.map.Site.id)
    pub id: i32,
    // @@protoc_insertion_point(field:perseus.api.v1.map.Site.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:perseus.api.v1.map.Site.type)
    pub type_: ::protobuf::EnumOrUnknown<site::SiteType>,
    // @@protoc_insertion_point(field:perseus.api.v1.map.Site.position)
    pub position: ::protobuf::MessageField<LanePoint>,
    // special fields
    // @@protoc_insertion_point(special_field:perseus.api.v1.map.Site.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Site {
    fn default() -> &'a Site {
        <Site as ::protobuf::Message>::default_instance()
    }
}

impl Site {
    pub fn new() -> Site {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Site| { &m.id },
            |m: &mut Site| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &Site| { &m.name },
            |m: &mut Site| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &Site| { &m.type_ },
            |m: &mut Site| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LanePoint>(
            "position",
            |m: &Site| { &m.position },
            |m: &mut Site| { &mut m.position },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Site>(
            "Site",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Site {
    const NAME: &'static str = "Site";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_int32()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                24 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.position)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(site::SiteType::None) {
            my_size += ::protobuf::rt::int32_size(3, self.type_.value());
        }
        if let Some(v) = self.position.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_int32(1, self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(site::SiteType::None) {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        if let Some(v) = self.position.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Site {
        Site::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.name.clear();
        self.type_ = ::protobuf::EnumOrUnknown::new(site::SiteType::None);
        self.position.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Site {
        static instance: Site = Site {
            id: 0,
            name: ::std::string::String::new(),
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            position: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Site {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Site").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Site {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Site {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Site`
pub mod site {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:perseus.api.v1.map.Site.SiteType)
    pub enum SiteType {
        // @@protoc_insertion_point(enum_value:perseus.api.v1.map.Site.SiteType.None)
        None = 0,
        // @@protoc_insertion_point(enum_value:perseus.api.v1.map.Site.SiteType.CleanSite)
        CleanSite = 1,
        // @@protoc_insertion_point(enum_value:perseus.api.v1.map.Site.SiteType.ChargingSite)
        ChargingSite = 2,
        // @@protoc_insertion_point(enum_value:perseus.api.v1.map.Site.SiteType.ParkingSite)
        ParkingSite = 3,
        // @@protoc_insertion_point(enum_value:perseus.api.v1.map.Site.SiteType.TransferSite)
        TransferSite = 4,
        // @@protoc_insertion_point(enum_value:perseus.api.v1.map.Site.SiteType.WaterSupplySite)
        WaterSupplySite = 5,
        // @@protoc_insertion_point(enum_value:perseus.api.v1.map.Site.SiteType.MaintenanceSite)
        MaintenanceSite = 6,
        // @@protoc_insertion_point(enum_value:perseus.api.v1.map.Site.SiteType.GasSite)
        GasSite = 7,
    }

    impl ::protobuf::Enum for SiteType {
        const NAME: &'static str = "SiteType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<SiteType> {
            match value {
                0 => ::std::option::Option::Some(SiteType::None),
                1 => ::std::option::Option::Some(SiteType::CleanSite),
                2 => ::std::option::Option::Some(SiteType::ChargingSite),
                3 => ::std::option::Option::Some(SiteType::ParkingSite),
                4 => ::std::option::Option::Some(SiteType::TransferSite),
                5 => ::std::option::Option::Some(SiteType::WaterSupplySite),
                6 => ::std::option::Option::Some(SiteType::MaintenanceSite),
                7 => ::std::option::Option::Some(SiteType::GasSite),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<SiteType> {
            match str {
                "None" => ::std::option::Option::Some(SiteType::None),
                "CleanSite" => ::std::option::Option::Some(SiteType::CleanSite),
                "ChargingSite" => ::std::option::Option::Some(SiteType::ChargingSite),
                "ParkingSite" => ::std::option::Option::Some(SiteType::ParkingSite),
                "TransferSite" => ::std::option::Option::Some(SiteType::TransferSite),
                "WaterSupplySite" => ::std::option::Option::Some(SiteType::WaterSupplySite),
                "MaintenanceSite" => ::std::option::Option::Some(SiteType::MaintenanceSite),
                "GasSite" => ::std::option::Option::Some(SiteType::GasSite),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [SiteType] = &[
            SiteType::None,
            SiteType::CleanSite,
            SiteType::ChargingSite,
            SiteType::ParkingSite,
            SiteType::TransferSite,
            SiteType::WaterSupplySite,
            SiteType::MaintenanceSite,
            SiteType::GasSite,
        ];
    }

    impl ::protobuf::EnumFull for SiteType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("Site.SiteType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for SiteType {
        fn default() -> Self {
            SiteType::None
        }
    }

    impl SiteType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<SiteType>("Site.SiteType")
        }
    }
}

// @@protoc_insertion_point(message:perseus.api.v1.map.Header)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Header {
    // message fields
    // @@protoc_insertion_point(field:perseus.api.v1.map.Header.major_version)
    pub major_version: i32,
    // @@protoc_insertion_point(field:perseus.api.v1.map.Header.minor_version)
    pub minor_version: i32,
    // @@protoc_insertion_point(field:perseus.api.v1.map.Header.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:perseus.api.v1.map.Header.date)
    pub date: ::std::string::String,
    // @@protoc_insertion_point(field:perseus.api.v1.map.Header.coordinate)
    pub coordinate: ::protobuf::EnumOrUnknown<header::Coordinate>,
    // special fields
    // @@protoc_insertion_point(special_field:perseus.api.v1.map.Header.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Header {
    fn default() -> &'a Header {
        <Header as ::protobuf::Message>::default_instance()
    }
}

impl Header {
    pub fn new() -> Header {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "major_version",
            |m: &Header| { &m.major_version },
            |m: &mut Header| { &mut m.major_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "minor_version",
            |m: &Header| { &m.minor_version },
            |m: &mut Header| { &mut m.minor_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &Header| { &m.name },
            |m: &mut Header| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "date",
            |m: &Header| { &m.date },
            |m: &mut Header| { &mut m.date },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "coordinate",
            |m: &Header| { &m.coordinate },
            |m: &mut Header| { &mut m.coordinate },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Header>(
            "Header",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Header {
    const NAME: &'static str = "Header";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.major_version = is.read_int32()?;
                },
                16 => {
                    self.minor_version = is.read_int32()?;
                },
                26 => {
                    self.name = is.read_string()?;
                },
                34 => {
                    self.date = is.read_string()?;
                },
                40 => {
                    self.coordinate = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.major_version != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.major_version);
        }
        if self.minor_version != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.minor_version);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.date.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.date);
        }
        if self.coordinate != ::protobuf::EnumOrUnknown::new(header::Coordinate::None) {
            my_size += ::protobuf::rt::int32_size(5, self.coordinate.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.major_version != 0 {
            os.write_int32(1, self.major_version)?;
        }
        if self.minor_version != 0 {
            os.write_int32(2, self.minor_version)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.date.is_empty() {
            os.write_string(4, &self.date)?;
        }
        if self.coordinate != ::protobuf::EnumOrUnknown::new(header::Coordinate::None) {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&self.coordinate))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Header {
        Header::new()
    }

    fn clear(&mut self) {
        self.major_version = 0;
        self.minor_version = 0;
        self.name.clear();
        self.date.clear();
        self.coordinate = ::protobuf::EnumOrUnknown::new(header::Coordinate::None);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Header {
        static instance: Header = Header {
            major_version: 0,
            minor_version: 0,
            name: ::std::string::String::new(),
            date: ::std::string::String::new(),
            coordinate: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Header {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Header").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Header {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Header {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Header`
pub mod header {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:perseus.api.v1.map.Header.Coordinate)
    pub enum Coordinate {
        // @@protoc_insertion_point(enum_value:perseus.api.v1.map.Header.Coordinate.None)
        None = 0,
        // @@protoc_insertion_point(enum_value:perseus.api.v1.map.Header.Coordinate.BD09)
        BD09 = 1,
        // @@protoc_insertion_point(enum_value:perseus.api.v1.map.Header.Coordinate.WGS84)
        WGS84 = 2,
    }

    impl ::protobuf::Enum for Coordinate {
        const NAME: &'static str = "Coordinate";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Coordinate> {
            match value {
                0 => ::std::option::Option::Some(Coordinate::None),
                1 => ::std::option::Option::Some(Coordinate::BD09),
                2 => ::std::option::Option::Some(Coordinate::WGS84),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Coordinate> {
            match str {
                "None" => ::std::option::Option::Some(Coordinate::None),
                "BD09" => ::std::option::Option::Some(Coordinate::BD09),
                "WGS84" => ::std::option::Option::Some(Coordinate::WGS84),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Coordinate] = &[
            Coordinate::None,
            Coordinate::BD09,
            Coordinate::WGS84,
        ];
    }

    impl ::protobuf::EnumFull for Coordinate {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("Header.Coordinate").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Coordinate {
        fn default() -> Self {
            Coordinate::None
        }
    }

    impl Coordinate {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<Coordinate>("Header.Coordinate")
        }
    }
}

// @@protoc_insertion_point(message:perseus.api.v1.map.Junction)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Junction {
    // message fields
    // @@protoc_insertion_point(field:perseus.api.v1.map.Junction.id)
    pub id: i32,
    // @@protoc_insertion_point(field:perseus.api.v1.map.Junction.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:perseus.api.v1.map.Junction.position)
    pub position: ::protobuf::MessageField<LanePoint>,
    // @@protoc_insertion_point(field:perseus.api.v1.map.Junction.polygon)
    pub polygon: ::std::vec::Vec<LanePoint>,
    // @@protoc_insertion_point(field:perseus.api.v1.map.Junction.connection)
    pub connection: ::std::vec::Vec<junction::ConnectionInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:perseus.api.v1.map.Junction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Junction {
    fn default() -> &'a Junction {
        <Junction as ::protobuf::Message>::default_instance()
    }
}

impl Junction {
    pub fn new() -> Junction {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Junction| { &m.id },
            |m: &mut Junction| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &Junction| { &m.name },
            |m: &mut Junction| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LanePoint>(
            "position",
            |m: &Junction| { &m.position },
            |m: &mut Junction| { &mut m.position },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "polygon",
            |m: &Junction| { &m.polygon },
            |m: &mut Junction| { &mut m.polygon },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "connection",
            |m: &Junction| { &m.connection },
            |m: &mut Junction| { &mut m.connection },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Junction>(
            "Junction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Junction {
    const NAME: &'static str = "Junction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_int32()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.position)?;
                },
                34 => {
                    self.polygon.push(is.read_message()?);
                },
                42 => {
                    self.connection.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if let Some(v) = self.position.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.polygon {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.connection {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_int32(1, self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if let Some(v) = self.position.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        for v in &self.polygon {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.connection {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Junction {
        Junction::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.name.clear();
        self.position.clear();
        self.polygon.clear();
        self.connection.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Junction {
        static instance: Junction = Junction {
            id: 0,
            name: ::std::string::String::new(),
            position: ::protobuf::MessageField::none(),
            polygon: ::std::vec::Vec::new(),
            connection: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Junction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Junction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Junction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Junction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Junction`
pub mod junction {
    // @@protoc_insertion_point(message:perseus.api.v1.map.Junction.ConnectionInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ConnectionInfo {
        // message fields
        // @@protoc_insertion_point(field:perseus.api.v1.map.Junction.ConnectionInfo.id)
        pub id: i32,
        // @@protoc_insertion_point(field:perseus.api.v1.map.Junction.ConnectionInfo.road_in)
        pub road_in: ::std::string::String,
        // @@protoc_insertion_point(field:perseus.api.v1.map.Junction.ConnectionInfo.road_out)
        pub road_out: ::std::string::String,
        // special fields
        // @@protoc_insertion_point(special_field:perseus.api.v1.map.Junction.ConnectionInfo.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ConnectionInfo {
        fn default() -> &'a ConnectionInfo {
            <ConnectionInfo as ::protobuf::Message>::default_instance()
        }
    }

    impl ConnectionInfo {
        pub fn new() -> ConnectionInfo {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "id",
                |m: &ConnectionInfo| { &m.id },
                |m: &mut ConnectionInfo| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "road_in",
                |m: &ConnectionInfo| { &m.road_in },
                |m: &mut ConnectionInfo| { &mut m.road_in },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "road_out",
                |m: &ConnectionInfo| { &m.road_out },
                |m: &mut ConnectionInfo| { &mut m.road_out },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ConnectionInfo>(
                "Junction.ConnectionInfo",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ConnectionInfo {
        const NAME: &'static str = "ConnectionInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.id = is.read_int32()?;
                    },
                    18 => {
                        self.road_in = is.read_string()?;
                    },
                    26 => {
                        self.road_out = is.read_string()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.id != 0 {
                my_size += ::protobuf::rt::int32_size(1, self.id);
            }
            if !self.road_in.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.road_in);
            }
            if !self.road_out.is_empty() {
                my_size += ::protobuf::rt::string_size(3, &self.road_out);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.id != 0 {
                os.write_int32(1, self.id)?;
            }
            if !self.road_in.is_empty() {
                os.write_string(2, &self.road_in)?;
            }
            if !self.road_out.is_empty() {
                os.write_string(3, &self.road_out)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ConnectionInfo {
            ConnectionInfo::new()
        }

        fn clear(&mut self) {
            self.id = 0;
            self.road_in.clear();
            self.road_out.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ConnectionInfo {
            static instance: ConnectionInfo = ConnectionInfo {
                id: 0,
                road_in: ::std::string::String::new(),
                road_out: ::std::string::String::new(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ConnectionInfo {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Junction.ConnectionInfo").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ConnectionInfo {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ConnectionInfo {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:perseus.api.v1.map.Lane)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Lane {
    // message fields
    // @@protoc_insertion_point(field:perseus.api.v1.map.Lane.id)
    pub id: i32,
    // @@protoc_insertion_point(field:perseus.api.v1.map.Lane.type)
    pub type_: ::protobuf::EnumOrUnknown<lane::LaneType>,
    // @@protoc_insertion_point(field:perseus.api.v1.map.Lane.central_line)
    pub central_line: ::protobuf::MessageField<LineCurve>,
    // @@protoc_insertion_point(field:perseus.api.v1.map.Lane.width)
    pub width: f32,
    // special fields
    // @@protoc_insertion_point(special_field:perseus.api.v1.map.Lane.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Lane {
    fn default() -> &'a Lane {
        <Lane as ::protobuf::Message>::default_instance()
    }
}

impl Lane {
    pub fn new() -> Lane {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Lane| { &m.id },
            |m: &mut Lane| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &Lane| { &m.type_ },
            |m: &mut Lane| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LineCurve>(
            "central_line",
            |m: &Lane| { &m.central_line },
            |m: &mut Lane| { &mut m.central_line },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "width",
            |m: &Lane| { &m.width },
            |m: &mut Lane| { &mut m.width },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Lane>(
            "Lane",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Lane {
    const NAME: &'static str = "Lane";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_int32()?;
                },
                16 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.central_line)?;
                },
                37 => {
                    self.width = is.read_float()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.id);
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(lane::LaneType::NONE) {
            my_size += ::protobuf::rt::int32_size(2, self.type_.value());
        }
        if let Some(v) = self.central_line.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.width != 0. {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_int32(1, self.id)?;
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(lane::LaneType::NONE) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        if let Some(v) = self.central_line.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if self.width != 0. {
            os.write_float(4, self.width)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Lane {
        Lane::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.type_ = ::protobuf::EnumOrUnknown::new(lane::LaneType::NONE);
        self.central_line.clear();
        self.width = 0.;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Lane {
        static instance: Lane = Lane {
            id: 0,
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            central_line: ::protobuf::MessageField::none(),
            width: 0.,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Lane {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Lane").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Lane {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Lane {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Lane`
pub mod lane {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:perseus.api.v1.map.Lane.LaneType)
    pub enum LaneType {
        // @@protoc_insertion_point(enum_value:perseus.api.v1.map.Lane.LaneType.NONE)
        NONE = 0,
        // @@protoc_insertion_point(enum_value:perseus.api.v1.map.Lane.LaneType.CityDriving)
        CityDriving = 1,
        // @@protoc_insertion_point(enum_value:perseus.api.v1.map.Lane.LaneType.SideWalk)
        SideWalk = 2,
        // @@protoc_insertion_point(enum_value:perseus.api.v1.map.Lane.LaneType.Shoulder)
        Shoulder = 3,
        // @@protoc_insertion_point(enum_value:perseus.api.v1.map.Lane.LaneType.Bus)
        Bus = 4,
        // @@protoc_insertion_point(enum_value:perseus.api.v1.map.Lane.LaneType.Biking)
        Biking = 5,
        // @@protoc_insertion_point(enum_value:perseus.api.v1.map.Lane.LaneType.Parking)
        Parking = 6,
        // @@protoc_insertion_point(enum_value:perseus.api.v1.map.Lane.LaneType.Bidirectional)
        Bidirectional = 7,
    }

    impl ::protobuf::Enum for LaneType {
        const NAME: &'static str = "LaneType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<LaneType> {
            match value {
                0 => ::std::option::Option::Some(LaneType::NONE),
                1 => ::std::option::Option::Some(LaneType::CityDriving),
                2 => ::std::option::Option::Some(LaneType::SideWalk),
                3 => ::std::option::Option::Some(LaneType::Shoulder),
                4 => ::std::option::Option::Some(LaneType::Bus),
                5 => ::std::option::Option::Some(LaneType::Biking),
                6 => ::std::option::Option::Some(LaneType::Parking),
                7 => ::std::option::Option::Some(LaneType::Bidirectional),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<LaneType> {
            match str {
                "NONE" => ::std::option::Option::Some(LaneType::NONE),
                "CityDriving" => ::std::option::Option::Some(LaneType::CityDriving),
                "SideWalk" => ::std::option::Option::Some(LaneType::SideWalk),
                "Shoulder" => ::std::option::Option::Some(LaneType::Shoulder),
                "Bus" => ::std::option::Option::Some(LaneType::Bus),
                "Biking" => ::std::option::Option::Some(LaneType::Biking),
                "Parking" => ::std::option::Option::Some(LaneType::Parking),
                "Bidirectional" => ::std::option::Option::Some(LaneType::Bidirectional),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [LaneType] = &[
            LaneType::NONE,
            LaneType::CityDriving,
            LaneType::SideWalk,
            LaneType::Shoulder,
            LaneType::Bus,
            LaneType::Biking,
            LaneType::Parking,
            LaneType::Bidirectional,
        ];
    }

    impl ::protobuf::EnumFull for LaneType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("Lane.LaneType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for LaneType {
        fn default() -> Self {
            LaneType::NONE
        }
    }

    impl LaneType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<LaneType>("Lane.LaneType")
        }
    }
}

// @@protoc_insertion_point(message:perseus.api.v1.map.LineCurve)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LineCurve {
    // message fields
    // @@protoc_insertion_point(field:perseus.api.v1.map.LineCurve.segments)
    pub segments: ::std::vec::Vec<line_curve::GeometryLine>,
    // @@protoc_insertion_point(field:perseus.api.v1.map.LineCurve.length)
    pub length: f32,
    // special fields
    // @@protoc_insertion_point(special_field:perseus.api.v1.map.LineCurve.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LineCurve {
    fn default() -> &'a LineCurve {
        <LineCurve as ::protobuf::Message>::default_instance()
    }
}

impl LineCurve {
    pub fn new() -> LineCurve {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "segments",
            |m: &LineCurve| { &m.segments },
            |m: &mut LineCurve| { &mut m.segments },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "length",
            |m: &LineCurve| { &m.length },
            |m: &mut LineCurve| { &mut m.length },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LineCurve>(
            "LineCurve",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LineCurve {
    const NAME: &'static str = "LineCurve";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.segments.push(is.read_message()?);
                },
                21 => {
                    self.length = is.read_float()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.segments {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.length != 0. {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.segments {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if self.length != 0. {
            os.write_float(2, self.length)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LineCurve {
        LineCurve::new()
    }

    fn clear(&mut self) {
        self.segments.clear();
        self.length = 0.;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LineCurve {
        static instance: LineCurve = LineCurve {
            segments: ::std::vec::Vec::new(),
            length: 0.,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LineCurve {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LineCurve").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LineCurve {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LineCurve {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `LineCurve`
pub mod line_curve {
    // @@protoc_insertion_point(message:perseus.api.v1.map.LineCurve.StraightLine)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct StraightLine {
        // message fields
        // @@protoc_insertion_point(field:perseus.api.v1.map.LineCurve.StraightLine.hdg)
        pub hdg: f32,
        // @@protoc_insertion_point(field:perseus.api.v1.map.LineCurve.StraightLine.length)
        pub length: f32,
        // @@protoc_insertion_point(field:perseus.api.v1.map.LineCurve.StraightLine.start_s)
        pub start_s: f32,
        // @@protoc_insertion_point(field:perseus.api.v1.map.LineCurve.StraightLine.position)
        pub position: ::protobuf::MessageField<super::LanePoint>,
        // special fields
        // @@protoc_insertion_point(special_field:perseus.api.v1.map.LineCurve.StraightLine.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a StraightLine {
        fn default() -> &'a StraightLine {
            <StraightLine as ::protobuf::Message>::default_instance()
        }
    }

    impl StraightLine {
        pub fn new() -> StraightLine {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "hdg",
                |m: &StraightLine| { &m.hdg },
                |m: &mut StraightLine| { &mut m.hdg },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "length",
                |m: &StraightLine| { &m.length },
                |m: &mut StraightLine| { &mut m.length },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "start_s",
                |m: &StraightLine| { &m.start_s },
                |m: &mut StraightLine| { &mut m.start_s },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::LanePoint>(
                "position",
                |m: &StraightLine| { &m.position },
                |m: &mut StraightLine| { &mut m.position },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<StraightLine>(
                "LineCurve.StraightLine",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for StraightLine {
        const NAME: &'static str = "StraightLine";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    13 => {
                        self.hdg = is.read_float()?;
                    },
                    21 => {
                        self.length = is.read_float()?;
                    },
                    29 => {
                        self.start_s = is.read_float()?;
                    },
                    34 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.position)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.hdg != 0. {
                my_size += 1 + 4;
            }
            if self.length != 0. {
                my_size += 1 + 4;
            }
            if self.start_s != 0. {
                my_size += 1 + 4;
            }
            if let Some(v) = self.position.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.hdg != 0. {
                os.write_float(1, self.hdg)?;
            }
            if self.length != 0. {
                os.write_float(2, self.length)?;
            }
            if self.start_s != 0. {
                os.write_float(3, self.start_s)?;
            }
            if let Some(v) = self.position.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> StraightLine {
            StraightLine::new()
        }

        fn clear(&mut self) {
            self.hdg = 0.;
            self.length = 0.;
            self.start_s = 0.;
            self.position.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static StraightLine {
            static instance: StraightLine = StraightLine {
                hdg: 0.,
                length: 0.,
                start_s: 0.,
                position: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for StraightLine {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("LineCurve.StraightLine").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for StraightLine {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for StraightLine {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:perseus.api.v1.map.LineCurve.ArcLine)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ArcLine {
        // message fields
        // @@protoc_insertion_point(field:perseus.api.v1.map.LineCurve.ArcLine.hdg)
        pub hdg: f32,
        // @@protoc_insertion_point(field:perseus.api.v1.map.LineCurve.ArcLine.length)
        pub length: f32,
        // @@protoc_insertion_point(field:perseus.api.v1.map.LineCurve.ArcLine.start_s)
        pub start_s: f32,
        // @@protoc_insertion_point(field:perseus.api.v1.map.LineCurve.ArcLine.position)
        pub position: ::protobuf::MessageField<super::LanePoint>,
        // @@protoc_insertion_point(field:perseus.api.v1.map.LineCurve.ArcLine.curvature)
        pub curvature: f32,
        // special fields
        // @@protoc_insertion_point(special_field:perseus.api.v1.map.LineCurve.ArcLine.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ArcLine {
        fn default() -> &'a ArcLine {
            <ArcLine as ::protobuf::Message>::default_instance()
        }
    }

    impl ArcLine {
        pub fn new() -> ArcLine {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "hdg",
                |m: &ArcLine| { &m.hdg },
                |m: &mut ArcLine| { &mut m.hdg },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "length",
                |m: &ArcLine| { &m.length },
                |m: &mut ArcLine| { &mut m.length },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "start_s",
                |m: &ArcLine| { &m.start_s },
                |m: &mut ArcLine| { &mut m.start_s },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::LanePoint>(
                "position",
                |m: &ArcLine| { &m.position },
                |m: &mut ArcLine| { &mut m.position },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "curvature",
                |m: &ArcLine| { &m.curvature },
                |m: &mut ArcLine| { &mut m.curvature },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ArcLine>(
                "LineCurve.ArcLine",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for ArcLine {
        const NAME: &'static str = "ArcLine";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    13 => {
                        self.hdg = is.read_float()?;
                    },
                    21 => {
                        self.length = is.read_float()?;
                    },
                    29 => {
                        self.start_s = is.read_float()?;
                    },
                    34 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.position)?;
                    },
                    45 => {
                        self.curvature = is.read_float()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.hdg != 0. {
                my_size += 1 + 4;
            }
            if self.length != 0. {
                my_size += 1 + 4;
            }
            if self.start_s != 0. {
                my_size += 1 + 4;
            }
            if let Some(v) = self.position.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if self.curvature != 0. {
                my_size += 1 + 4;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.hdg != 0. {
                os.write_float(1, self.hdg)?;
            }
            if self.length != 0. {
                os.write_float(2, self.length)?;
            }
            if self.start_s != 0. {
                os.write_float(3, self.start_s)?;
            }
            if let Some(v) = self.position.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            }
            if self.curvature != 0. {
                os.write_float(5, self.curvature)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ArcLine {
            ArcLine::new()
        }

        fn clear(&mut self) {
            self.hdg = 0.;
            self.length = 0.;
            self.start_s = 0.;
            self.position.clear();
            self.curvature = 0.;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ArcLine {
            static instance: ArcLine = ArcLine {
                hdg: 0.,
                length: 0.,
                start_s: 0.,
                position: ::protobuf::MessageField::none(),
                curvature: 0.,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for ArcLine {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("LineCurve.ArcLine").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ArcLine {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for ArcLine {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:perseus.api.v1.map.LineCurve.SpiralLine)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SpiralLine {
        // message fields
        // @@protoc_insertion_point(field:perseus.api.v1.map.LineCurve.SpiralLine.hdg)
        pub hdg: f32,
        // @@protoc_insertion_point(field:perseus.api.v1.map.LineCurve.SpiralLine.length)
        pub length: f32,
        // @@protoc_insertion_point(field:perseus.api.v1.map.LineCurve.SpiralLine.start_s)
        pub start_s: f32,
        // @@protoc_insertion_point(field:perseus.api.v1.map.LineCurve.SpiralLine.position)
        pub position: ::protobuf::MessageField<super::LanePoint>,
        // @@protoc_insertion_point(field:perseus.api.v1.map.LineCurve.SpiralLine.curvature_start)
        pub curvature_start: f32,
        // @@protoc_insertion_point(field:perseus.api.v1.map.LineCurve.SpiralLine.curvature_end)
        pub curvature_end: f32,
        // special fields
        // @@protoc_insertion_point(special_field:perseus.api.v1.map.LineCurve.SpiralLine.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SpiralLine {
        fn default() -> &'a SpiralLine {
            <SpiralLine as ::protobuf::Message>::default_instance()
        }
    }

    impl SpiralLine {
        pub fn new() -> SpiralLine {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(6);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "hdg",
                |m: &SpiralLine| { &m.hdg },
                |m: &mut SpiralLine| { &mut m.hdg },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "length",
                |m: &SpiralLine| { &m.length },
                |m: &mut SpiralLine| { &mut m.length },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "start_s",
                |m: &SpiralLine| { &m.start_s },
                |m: &mut SpiralLine| { &mut m.start_s },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::LanePoint>(
                "position",
                |m: &SpiralLine| { &m.position },
                |m: &mut SpiralLine| { &mut m.position },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "curvature_start",
                |m: &SpiralLine| { &m.curvature_start },
                |m: &mut SpiralLine| { &mut m.curvature_start },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "curvature_end",
                |m: &SpiralLine| { &m.curvature_end },
                |m: &mut SpiralLine| { &mut m.curvature_end },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SpiralLine>(
                "LineCurve.SpiralLine",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for SpiralLine {
        const NAME: &'static str = "SpiralLine";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    13 => {
                        self.hdg = is.read_float()?;
                    },
                    21 => {
                        self.length = is.read_float()?;
                    },
                    29 => {
                        self.start_s = is.read_float()?;
                    },
                    34 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.position)?;
                    },
                    45 => {
                        self.curvature_start = is.read_float()?;
                    },
                    53 => {
                        self.curvature_end = is.read_float()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if self.hdg != 0. {
                my_size += 1 + 4;
            }
            if self.length != 0. {
                my_size += 1 + 4;
            }
            if self.start_s != 0. {
                my_size += 1 + 4;
            }
            if let Some(v) = self.position.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if self.curvature_start != 0. {
                my_size += 1 + 4;
            }
            if self.curvature_end != 0. {
                my_size += 1 + 4;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if self.hdg != 0. {
                os.write_float(1, self.hdg)?;
            }
            if self.length != 0. {
                os.write_float(2, self.length)?;
            }
            if self.start_s != 0. {
                os.write_float(3, self.start_s)?;
            }
            if let Some(v) = self.position.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            }
            if self.curvature_start != 0. {
                os.write_float(5, self.curvature_start)?;
            }
            if self.curvature_end != 0. {
                os.write_float(6, self.curvature_end)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SpiralLine {
            SpiralLine::new()
        }

        fn clear(&mut self) {
            self.hdg = 0.;
            self.length = 0.;
            self.start_s = 0.;
            self.position.clear();
            self.curvature_start = 0.;
            self.curvature_end = 0.;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SpiralLine {
            static instance: SpiralLine = SpiralLine {
                hdg: 0.,
                length: 0.,
                start_s: 0.,
                position: ::protobuf::MessageField::none(),
                curvature_start: 0.,
                curvature_end: 0.,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for SpiralLine {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("LineCurve.SpiralLine").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for SpiralLine {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for SpiralLine {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    // @@protoc_insertion_point(message:perseus.api.v1.map.LineCurve.GeometryLine)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct GeometryLine {
        // message fields
        // @@protoc_insertion_point(field:perseus.api.v1.map.LineCurve.GeometryLine.straight)
        pub straight: ::protobuf::MessageField<StraightLine>,
        // @@protoc_insertion_point(field:perseus.api.v1.map.LineCurve.GeometryLine.arc)
        pub arc: ::protobuf::MessageField<ArcLine>,
        // @@protoc_insertion_point(field:perseus.api.v1.map.LineCurve.GeometryLine.spiral)
        pub spiral: ::protobuf::MessageField<SpiralLine>,
        // special fields
        // @@protoc_insertion_point(special_field:perseus.api.v1.map.LineCurve.GeometryLine.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a GeometryLine {
        fn default() -> &'a GeometryLine {
            <GeometryLine as ::protobuf::Message>::default_instance()
        }
    }

    impl GeometryLine {
        pub fn new() -> GeometryLine {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, StraightLine>(
                "straight",
                |m: &GeometryLine| { &m.straight },
                |m: &mut GeometryLine| { &mut m.straight },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ArcLine>(
                "arc",
                |m: &GeometryLine| { &m.arc },
                |m: &mut GeometryLine| { &mut m.arc },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, SpiralLine>(
                "spiral",
                |m: &GeometryLine| { &m.spiral },
                |m: &mut GeometryLine| { &mut m.spiral },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GeometryLine>(
                "LineCurve.GeometryLine",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for GeometryLine {
        const NAME: &'static str = "GeometryLine";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.straight)?;
                    },
                    18 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.arc)?;
                    },
                    26 => {
                        ::protobuf::rt::read_singular_message_into_field(is, &mut self.spiral)?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.straight.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.arc.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.spiral.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if let Some(v) = self.straight.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            if let Some(v) = self.arc.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            if let Some(v) = self.spiral.as_ref() {
                ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> GeometryLine {
            GeometryLine::new()
        }

        fn clear(&mut self) {
            self.straight.clear();
            self.arc.clear();
            self.spiral.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static GeometryLine {
            static instance: GeometryLine = GeometryLine {
                straight: ::protobuf::MessageField::none(),
                arc: ::protobuf::MessageField::none(),
                spiral: ::protobuf::MessageField::none(),
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for GeometryLine {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("LineCurve.GeometryLine").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for GeometryLine {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for GeometryLine {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:perseus.api.v1.map.Road)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Road {
    // message fields
    // @@protoc_insertion_point(field:perseus.api.v1.map.Road.id)
    pub id: i32,
    // @@protoc_insertion_point(field:perseus.api.v1.map.Road.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:perseus.api.v1.map.Road.length)
    pub length: f32,
    // @@protoc_insertion_point(field:perseus.api.v1.map.Road.type)
    pub type_: ::protobuf::EnumOrUnknown<road::RoadType>,
    // @@protoc_insertion_point(field:perseus.api.v1.map.Road.central_line)
    pub central_line: ::protobuf::MessageField<LineCurve>,
    // @@protoc_insertion_point(field:perseus.api.v1.map.Road.left_lanes)
    pub left_lanes: ::std::vec::Vec<Lane>,
    // @@protoc_insertion_point(field:perseus.api.v1.map.Road.right_lanes)
    pub right_lanes: ::std::vec::Vec<Lane>,
    // @@protoc_insertion_point(field:perseus.api.v1.map.Road.link)
    pub link: ::std::vec::Vec<road::RoadLink>,
    // special fields
    // @@protoc_insertion_point(special_field:perseus.api.v1.map.Road.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Road {
    fn default() -> &'a Road {
        <Road as ::protobuf::Message>::default_instance()
    }
}

impl Road {
    pub fn new() -> Road {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &Road| { &m.id },
            |m: &mut Road| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &Road| { &m.name },
            |m: &mut Road| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "length",
            |m: &Road| { &m.length },
            |m: &mut Road| { &mut m.length },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &Road| { &m.type_ },
            |m: &mut Road| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, LineCurve>(
            "central_line",
            |m: &Road| { &m.central_line },
            |m: &mut Road| { &mut m.central_line },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "left_lanes",
            |m: &Road| { &m.left_lanes },
            |m: &mut Road| { &mut m.left_lanes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "right_lanes",
            |m: &Road| { &m.right_lanes },
            |m: &mut Road| { &mut m.right_lanes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "link",
            |m: &Road| { &m.link },
            |m: &mut Road| { &mut m.link },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Road>(
            "Road",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Road {
    const NAME: &'static str = "Road";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = is.read_int32()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                29 => {
                    self.length = is.read_float()?;
                },
                32 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.central_line)?;
                },
                50 => {
                    self.left_lanes.push(is.read_message()?);
                },
                58 => {
                    self.right_lanes.push(is.read_message()?);
                },
                66 => {
                    self.link.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::int32_size(1, self.id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if self.length != 0. {
            my_size += 1 + 4;
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(road::RoadType::None) {
            my_size += ::protobuf::rt::int32_size(4, self.type_.value());
        }
        if let Some(v) = self.central_line.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.left_lanes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.right_lanes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.link {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.id != 0 {
            os.write_int32(1, self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if self.length != 0. {
            os.write_float(3, self.length)?;
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(road::RoadType::None) {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        if let Some(v) = self.central_line.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        for v in &self.left_lanes {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        for v in &self.right_lanes {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        for v in &self.link {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Road {
        Road::new()
    }

    fn clear(&mut self) {
        self.id = 0;
        self.name.clear();
        self.length = 0.;
        self.type_ = ::protobuf::EnumOrUnknown::new(road::RoadType::None);
        self.central_line.clear();
        self.left_lanes.clear();
        self.right_lanes.clear();
        self.link.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Road {
        static instance: Road = Road {
            id: 0,
            name: ::std::string::String::new(),
            length: 0.,
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            central_line: ::protobuf::MessageField::none(),
            left_lanes: ::std::vec::Vec::new(),
            right_lanes: ::std::vec::Vec::new(),
            link: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Road {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Road").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Road {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Road {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `Road`
pub mod road {
    // @@protoc_insertion_point(message:perseus.api.v1.map.Road.RoadLink)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct RoadLink {
        // message fields
        // @@protoc_insertion_point(field:perseus.api.v1.map.Road.RoadLink.link_type)
        pub link_type: ::std::string::String,
        // @@protoc_insertion_point(field:perseus.api.v1.map.Road.RoadLink.element_type)
        pub element_type: ::std::string::String,
        // @@protoc_insertion_point(field:perseus.api.v1.map.Road.RoadLink.element_id)
        pub element_id: i32,
        // special fields
        // @@protoc_insertion_point(special_field:perseus.api.v1.map.Road.RoadLink.special_fields)
        pub special_fields: ::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RoadLink {
        fn default() -> &'a RoadLink {
            <RoadLink as ::protobuf::Message>::default_instance()
        }
    }

    impl RoadLink {
        pub fn new() -> RoadLink {
            ::std::default::Default::default()
        }

        pub(in super) fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "link_type",
                |m: &RoadLink| { &m.link_type },
                |m: &mut RoadLink| { &mut m.link_type },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "element_type",
                |m: &RoadLink| { &m.element_type },
                |m: &mut RoadLink| { &mut m.element_type },
            ));
            fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
                "element_id",
                |m: &RoadLink| { &m.element_id },
                |m: &mut RoadLink| { &mut m.element_id },
            ));
            ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<RoadLink>(
                "Road.RoadLink",
                fields,
                oneofs,
            )
        }
    }

    impl ::protobuf::Message for RoadLink {
        const NAME: &'static str = "RoadLink";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.link_type = is.read_string()?;
                    },
                    18 => {
                        self.element_type = is.read_string()?;
                    },
                    24 => {
                        self.element_id = is.read_int32()?;
                    },
                    tag => {
                        ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if !self.link_type.is_empty() {
                my_size += ::protobuf::rt::string_size(1, &self.link_type);
            }
            if !self.element_type.is_empty() {
                my_size += ::protobuf::rt::string_size(2, &self.element_type);
            }
            if self.element_id != 0 {
                my_size += ::protobuf::rt::int32_size(3, self.element_id);
            }
            my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
            if !self.link_type.is_empty() {
                os.write_string(1, &self.link_type)?;
            }
            if !self.element_type.is_empty() {
                os.write_string(2, &self.element_type)?;
            }
            if self.element_id != 0 {
                os.write_int32(3, self.element_id)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RoadLink {
            RoadLink::new()
        }

        fn clear(&mut self) {
            self.link_type.clear();
            self.element_type.clear();
            self.element_id = 0;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RoadLink {
            static instance: RoadLink = RoadLink {
                link_type: ::std::string::String::new(),
                element_type: ::std::string::String::new(),
                element_id: 0,
                special_fields: ::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    impl ::protobuf::MessageFull for RoadLink {
        fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("Road.RoadLink").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for RoadLink {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            ::protobuf::text_format::fmt(self, f)
        }
    }

    impl ::protobuf::reflect::ProtobufValue for RoadLink {
        type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:perseus.api.v1.map.Road.RoadType)
    pub enum RoadType {
        // @@protoc_insertion_point(enum_value:perseus.api.v1.map.Road.RoadType.None)
        None = 0,
        // @@protoc_insertion_point(enum_value:perseus.api.v1.map.Road.RoadType.Major)
        Major = 1,
        // @@protoc_insertion_point(enum_value:perseus.api.v1.map.Road.RoadType.Minor)
        Minor = 2,
        // @@protoc_insertion_point(enum_value:perseus.api.v1.map.Road.RoadType.SideWalk)
        SideWalk = 3,
    }

    impl ::protobuf::Enum for RoadType {
        const NAME: &'static str = "RoadType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<RoadType> {
            match value {
                0 => ::std::option::Option::Some(RoadType::None),
                1 => ::std::option::Option::Some(RoadType::Major),
                2 => ::std::option::Option::Some(RoadType::Minor),
                3 => ::std::option::Option::Some(RoadType::SideWalk),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<RoadType> {
            match str {
                "None" => ::std::option::Option::Some(RoadType::None),
                "Major" => ::std::option::Option::Some(RoadType::Major),
                "Minor" => ::std::option::Option::Some(RoadType::Minor),
                "SideWalk" => ::std::option::Option::Some(RoadType::SideWalk),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [RoadType] = &[
            RoadType::None,
            RoadType::Major,
            RoadType::Minor,
            RoadType::SideWalk,
        ];
    }

    impl ::protobuf::EnumFull for RoadType {
        fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("Road.RoadType").unwrap()).clone()
        }

        fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for RoadType {
        fn default() -> Self {
            RoadType::None
        }
    }

    impl RoadType {
        pub(in super) fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
            ::protobuf::reflect::GeneratedEnumDescriptorData::new::<RoadType>("Road.RoadType")
        }
    }
}

// @@protoc_insertion_point(message:perseus.api.v1.map.Map)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Map {
    // message fields
    // @@protoc_insertion_point(field:perseus.api.v1.map.Map.header)
    pub header: ::protobuf::MessageField<Header>,
    // @@protoc_insertion_point(field:perseus.api.v1.map.Map.roads)
    pub roads: ::std::collections::HashMap<i32, Road>,
    // @@protoc_insertion_point(field:perseus.api.v1.map.Map.junctions)
    pub junctions: ::std::collections::HashMap<i32, Junction>,
    // @@protoc_insertion_point(field:perseus.api.v1.map.Map.clean_areas)
    pub clean_areas: ::std::collections::HashMap<i32, CleanArea>,
    // @@protoc_insertion_point(field:perseus.api.v1.map.Map.sites)
    pub sites: ::std::collections::HashMap<i32, Site>,
    // special fields
    // @@protoc_insertion_point(special_field:perseus.api.v1.map.Map.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Map {
    fn default() -> &'a Map {
        <Map as ::protobuf::Message>::default_instance()
    }
}

impl Map {
    pub fn new() -> Map {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Header>(
            "header",
            |m: &Map| { &m.header },
            |m: &mut Map| { &mut m.header },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "roads",
            |m: &Map| { &m.roads },
            |m: &mut Map| { &mut m.roads },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "junctions",
            |m: &Map| { &m.junctions },
            |m: &mut Map| { &mut m.junctions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "clean_areas",
            |m: &Map| { &m.clean_areas },
            |m: &mut Map| { &mut m.clean_areas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_map_simpler_accessor_new::<_, _>(
            "sites",
            |m: &Map| { &m.sites },
            |m: &mut Map| { &mut m.sites },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Map>(
            "Map",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Map {
    const NAME: &'static str = "Map";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.header)?;
                },
                18 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            8 => key = is.read_int32()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.roads.insert(key, value);
                },
                26 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            8 => key = is.read_int32()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.junctions.insert(key, value);
                },
                34 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            8 => key = is.read_int32()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.clean_areas.insert(key, value);
                },
                42 => {
                    let len = is.read_raw_varint32()?;
                    let old_limit = is.push_limit(len as u64)?;
                    let mut key = ::std::default::Default::default();
                    let mut value = ::std::default::Default::default();
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            8 => key = is.read_int32()?,
                            18 => value = is.read_message()?,
                            _ => ::protobuf::rt::skip_field_for_tag(tag, is)?,
                        };
                    }
                    is.pop_limit(old_limit);
                    self.sites.insert(key, value);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for (k, v) in &self.roads {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::int32_size(1, *k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.junctions {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::int32_size(1, *k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.clean_areas {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::int32_size(1, *k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        for (k, v) in &self.sites {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::int32_size(1, *k);
            let len = v.compute_size();
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(entry_size) + entry_size
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.header.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for (k, v) in &self.roads {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::int32_size(1, *k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(18)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_int32(1, *k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for (k, v) in &self.junctions {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::int32_size(1, *k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(26)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_int32(1, *k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for (k, v) in &self.clean_areas {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::int32_size(1, *k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(34)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_int32(1, *k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for (k, v) in &self.sites {
            let mut entry_size = 0;
            entry_size += ::protobuf::rt::int32_size(1, *k);
            let len = v.cached_size() as u64;
            entry_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
            os.write_raw_varint32(42)?; // Tag.
            os.write_raw_varint32(entry_size as u32)?;
            os.write_int32(1, *k)?;
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Map {
        Map::new()
    }

    fn clear(&mut self) {
        self.header.clear();
        self.roads.clear();
        self.junctions.clear();
        self.clean_areas.clear();
        self.sites.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Map {
        static instance: ::protobuf::rt::Lazy<Map> = ::protobuf::rt::Lazy::new();
        instance.get(Map::new)
    }
}

impl ::protobuf::MessageFull for Map {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Map").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Map {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Map {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\tmap.proto\x12\x12perseus.api.v1.map\"5\n\tLanePoint\x12\x0c\n\x01x\
    \x18\x01\x20\x01(\x01R\x01x\x12\x0c\n\x01y\x18\x02\x20\x01(\x01R\x01y\
    \x12\x0c\n\x01z\x18\x03\x20\x01(\x01R\x01z\"\xa3\x01\n\tCleanArea\x12\
    \x0e\n\x02id\x18\x01\x20\x01(\x05R\x02id\x12\x12\n\x04name\x18\x02\x20\
    \x01(\tR\x04name\x129\n\x08position\x18\x03\x20\x01(\x0b2\x1d.perseus.ap\
    i.v1.map.LanePointR\x08position\x127\n\x07polygon\x18\x04\x20\x03(\x0b2\
    \x1d.perseus.api.v1.map.LanePointR\x07polygon\"\xae\x02\n\x04Site\x12\
    \x0e\n\x02id\x18\x01\x20\x01(\x05R\x02id\x12\x12\n\x04name\x18\x02\x20\
    \x01(\tR\x04name\x125\n\x04type\x18\x03\x20\x01(\x0e2!.perseus.api.v1.ma\
    p.Site.SiteTypeR\x04type\x129\n\x08position\x18\x04\x20\x01(\x0b2\x1d.pe\
    rseus.api.v1.map.LanePointR\x08position\"\x8f\x01\n\x08SiteType\x12\x08\
    \n\x04None\x10\0\x12\r\n\tCleanSite\x10\x01\x12\x10\n\x0cChargingSite\
    \x10\x02\x12\x0f\n\x0bParkingSite\x10\x03\x12\x10\n\x0cTransferSite\x10\
    \x04\x12\x13\n\x0fWaterSupplySite\x10\x05\x12\x13\n\x0fMaintenanceSite\
    \x10\x06\x12\x0b\n\x07GasSite\x10\x07\"\xee\x01\n\x06Header\x12#\n\rmajo\
    r_version\x18\x01\x20\x01(\x05R\x0cmajorVersion\x12#\n\rminor_version\
    \x18\x02\x20\x01(\x05R\x0cminorVersion\x12\x12\n\x04name\x18\x03\x20\x01\
    (\tR\x04name\x12\x12\n\x04date\x18\x04\x20\x01(\tR\x04date\x12E\n\ncoord\
    inate\x18\x05\x20\x01(\x0e2%.perseus.api.v1.map.Header.CoordinateR\ncoor\
    dinate\"+\n\nCoordinate\x12\x08\n\x04None\x10\0\x12\x08\n\x04BD09\x10\
    \x01\x12\t\n\x05WGS84\x10\x02\"\xc5\x02\n\x08Junction\x12\x0e\n\x02id\
    \x18\x01\x20\x01(\x05R\x02id\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04na\
    me\x129\n\x08position\x18\x03\x20\x01(\x0b2\x1d.perseus.api.v1.map.LaneP\
    ointR\x08position\x127\n\x07polygon\x18\x04\x20\x03(\x0b2\x1d.perseus.ap\
    i.v1.map.LanePointR\x07polygon\x12K\n\nconnection\x18\x05\x20\x03(\x0b2+\
    .perseus.api.v1.map.Junction.ConnectionInfoR\nconnection\x1aT\n\x0eConne\
    ctionInfo\x12\x0e\n\x02id\x18\x01\x20\x01(\x05R\x02id\x12\x17\n\x07road_\
    in\x18\x02\x20\x01(\tR\x06roadIn\x12\x19\n\x08road_out\x18\x03\x20\x01(\
    \tR\x07roadOut\"\x9d\x02\n\x04Lane\x12\x0e\n\x02id\x18\x01\x20\x01(\x05R\
    \x02id\x125\n\x04type\x18\x02\x20\x01(\x0e2!.perseus.api.v1.map.Lane.Lan\
    eTypeR\x04type\x12@\n\x0ccentral_line\x18\x03\x20\x01(\x0b2\x1d.perseus.\
    api.v1.map.LineCurveR\x0bcentralLine\x12\x14\n\x05width\x18\x04\x20\x01(\
    \x02R\x05width\"v\n\x08LaneType\x12\x08\n\x04NONE\x10\0\x12\x0f\n\x0bCit\
    yDriving\x10\x01\x12\x0c\n\x08SideWalk\x10\x02\x12\x0c\n\x08Shoulder\x10\
    \x03\x12\x07\n\x03Bus\x10\x04\x12\n\n\x06Biking\x10\x05\x12\x0b\n\x07Par\
    king\x10\x06\x12\x11\n\rBidirectional\x10\x07\"\xd1\x06\n\tLineCurve\x12\
    F\n\x08segments\x18\x01\x20\x03(\x0b2*.perseus.api.v1.map.LineCurve.Geom\
    etryLineR\x08segments\x12\x16\n\x06length\x18\x02\x20\x01(\x02R\x06lengt\
    h\x1a\x8c\x01\n\x0cStraightLine\x12\x10\n\x03hdg\x18\x01\x20\x01(\x02R\
    \x03hdg\x12\x16\n\x06length\x18\x02\x20\x01(\x02R\x06length\x12\x17\n\
    \x07start_s\x18\x03\x20\x01(\x02R\x06startS\x129\n\x08position\x18\x04\
    \x20\x01(\x0b2\x1d.perseus.api.v1.map.LanePointR\x08position\x1a\xa5\x01\
    \n\x07ArcLine\x12\x10\n\x03hdg\x18\x01\x20\x01(\x02R\x03hdg\x12\x16\n\
    \x06length\x18\x02\x20\x01(\x02R\x06length\x12\x17\n\x07start_s\x18\x03\
    \x20\x01(\x02R\x06startS\x129\n\x08position\x18\x04\x20\x01(\x0b2\x1d.pe\
    rseus.api.v1.map.LanePointR\x08position\x12\x1c\n\tcurvature\x18\x05\x20\
    \x01(\x02R\tcurvature\x1a\xd8\x01\n\nSpiralLine\x12\x10\n\x03hdg\x18\x01\
    \x20\x01(\x02R\x03hdg\x12\x16\n\x06length\x18\x02\x20\x01(\x02R\x06lengt\
    h\x12\x17\n\x07start_s\x18\x03\x20\x01(\x02R\x06startS\x129\n\x08positio\
    n\x18\x04\x20\x01(\x0b2\x1d.perseus.api.v1.map.LanePointR\x08position\
    \x12'\n\x0fcurvature_start\x18\x05\x20\x01(\x02R\x0ecurvatureStart\x12#\
    \n\rcurvature_end\x18\x06\x20\x01(\x02R\x0ccurvatureEnd\x1a\xd1\x01\n\
    \x0cGeometryLine\x12F\n\x08straight\x18\x01\x20\x01(\x0b2*.perseus.api.v\
    1.map.LineCurve.StraightLineR\x08straight\x127\n\x03arc\x18\x02\x20\x01(\
    \x0b2%.perseus.api.v1.map.LineCurve.ArcLineR\x03arc\x12@\n\x06spiral\x18\
    \x03\x20\x01(\x0b2(.perseus.api.v1.map.LineCurve.SpiralLineR\x06spiral\"\
    \x8b\x04\n\x04Road\x12\x0e\n\x02id\x18\x01\x20\x01(\x05R\x02id\x12\x12\n\
    \x04name\x18\x02\x20\x01(\tR\x04name\x12\x16\n\x06length\x18\x03\x20\x01\
    (\x02R\x06length\x125\n\x04type\x18\x04\x20\x01(\x0e2!.perseus.api.v1.ma\
    p.Road.RoadTypeR\x04type\x12@\n\x0ccentral_line\x18\x05\x20\x01(\x0b2\
    \x1d.perseus.api.v1.map.LineCurveR\x0bcentralLine\x127\n\nleft_lanes\x18\
    \x06\x20\x03(\x0b2\x18.perseus.api.v1.map.LaneR\tleftLanes\x129\n\x0brig\
    ht_lanes\x18\x07\x20\x03(\x0b2\x18.perseus.api.v1.map.LaneR\nrightLanes\
    \x125\n\x04link\x18\x08\x20\x03(\x0b2!.perseus.api.v1.map.Road.RoadLinkR\
    \x04link\x1ai\n\x08RoadLink\x12\x1b\n\tlink_type\x18\x01\x20\x01(\tR\x08\
    linkType\x12!\n\x0celement_type\x18\x02\x20\x01(\tR\x0belementType\x12\
    \x1d\n\nelement_id\x18\x03\x20\x01(\x05R\telementId\"8\n\x08RoadType\x12\
    \x08\n\x04None\x10\0\x12\t\n\x05Major\x10\x01\x12\t\n\x05Minor\x10\x02\
    \x12\x0c\n\x08SideWalk\x10\x03\"\x9f\x05\n\x03Map\x122\n\x06header\x18\
    \x01\x20\x01(\x0b2\x1a.perseus.api.v1.map.HeaderR\x06header\x128\n\x05ro\
    ads\x18\x02\x20\x03(\x0b2\".perseus.api.v1.map.Map.RoadsEntryR\x05roads\
    \x12D\n\tjunctions\x18\x03\x20\x03(\x0b2&.perseus.api.v1.map.Map.Junctio\
    nsEntryR\tjunctions\x12H\n\x0bclean_areas\x18\x04\x20\x03(\x0b2'.perseus\
    .api.v1.map.Map.CleanAreasEntryR\ncleanAreas\x128\n\x05sites\x18\x05\x20\
    \x03(\x0b2\".perseus.api.v1.map.Map.SitesEntryR\x05sites\x1aR\n\nRoadsEn\
    try\x12\x10\n\x03key\x18\x01\x20\x01(\x05R\x03key\x12.\n\x05value\x18\
    \x02\x20\x01(\x0b2\x18.perseus.api.v1.map.RoadR\x05value:\x028\x01\x1aZ\
    \n\x0eJunctionsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\x05R\x03key\x122\
    \n\x05value\x18\x02\x20\x01(\x0b2\x1c.perseus.api.v1.map.JunctionR\x05va\
    lue:\x028\x01\x1a\\\n\x0fCleanAreasEntry\x12\x10\n\x03key\x18\x01\x20\
    \x01(\x05R\x03key\x123\n\x05value\x18\x02\x20\x01(\x0b2\x1d.perseus.api.\
    v1.map.CleanAreaR\x05value:\x028\x01\x1aR\n\nSitesEntry\x12\x10\n\x03key\
    \x18\x01\x20\x01(\x05R\x03key\x12.\n\x05value\x18\x02\x20\x01(\x0b2\x18.\
    perseus.api.v1.map.SiteR\x05value:\x028\x01b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(15);
            messages.push(LanePoint::generated_message_descriptor_data());
            messages.push(CleanArea::generated_message_descriptor_data());
            messages.push(Site::generated_message_descriptor_data());
            messages.push(Header::generated_message_descriptor_data());
            messages.push(Junction::generated_message_descriptor_data());
            messages.push(Lane::generated_message_descriptor_data());
            messages.push(LineCurve::generated_message_descriptor_data());
            messages.push(Road::generated_message_descriptor_data());
            messages.push(Map::generated_message_descriptor_data());
            messages.push(junction::ConnectionInfo::generated_message_descriptor_data());
            messages.push(line_curve::StraightLine::generated_message_descriptor_data());
            messages.push(line_curve::ArcLine::generated_message_descriptor_data());
            messages.push(line_curve::SpiralLine::generated_message_descriptor_data());
            messages.push(line_curve::GeometryLine::generated_message_descriptor_data());
            messages.push(road::RoadLink::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(4);
            enums.push(site::SiteType::generated_enum_descriptor_data());
            enums.push(header::Coordinate::generated_enum_descriptor_data());
            enums.push(lane::LaneType::generated_enum_descriptor_data());
            enums.push(road::RoadType::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
